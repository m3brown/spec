<?xml version="1.0" encoding="us-ascii"?>
<?xml-stylesheet type='text/xsl' href='http://xml2rfc.tools.ietf.org/authoring/rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="2"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc category="std" docName="draft-ietf-oauth-token-exchange-03"
     ipr="trust200902">
  <front>
    <title abbrev="OAuth 2.0 Token Exchange">OAuth 2.0 Token Exchange: An STS for the REST of Us</title>

    <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
      <organization>Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
        <uri>http://self-issued.info/</uri>
      </address>
    </author>
    <author fullname="Anthony Nadalin" initials="A." surname="Nadalin">
      <organization>Microsoft</organization>
      <address>
        <email>tonynad@microsoft.com</email>
      </address>
    </author>
    <author fullname="Brian Campbell" initials="B." surname="Campbell">
      <organization>Ping Identity</organization>
      <address><email>brian.d.campbell@gmail.com</email></address>
    </author>
    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization>Ping Identity</organization>
      <address><email>ve7jtb@ve7jtb.com</email></address>
    </author>
    <author fullname="Chuck Mortimore" initials="C." surname="Mortimore">
      <organization abbrev="Salesforce">Salesforce</organization>
      <address>
        <email>cmortimore@salesforce.com</email>
      </address>
    </author>

    <date />

    <area>Security</area>
    <workgroup>OAuth Working Group</workgroup>

    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>JSON Web Token</keyword>
    <keyword>JWT</keyword>
    <keyword>Delegation</keyword>
    <keyword>Impersonation</keyword>
    <keyword>STS</keyword>
    <keyword>Exchange</keyword>
    <keyword>Token</keyword>
    <keyword>OAuth</keyword>


    <abstract>
      <t>
	This specification defines a protocol for a lightweight HTTP- and JSON- based
	Security Token Service (STS) by defining how to request and obtain
	security tokens from OAuth 2.0 authorization servers,
	including security tokens employing impersonation and delegation.
      </t>
    </abstract>

  </front>

  <middle>
    <section anchor="Introduction" title="Introduction">
<t>
  A security token is a set of information that facilitates
  the sharing of identity and security information in heterogeneous environments or across security domains.
  Examples of security tokens include
  JSON Web Tokens (JWTs) <xref target="JWT"/> and
  SAML Assertions <xref target="OASIS.saml-core-2.0-os"/>.
  Security tokens are typically signed to achieve integrity
  and sometimes also encrypted to achieve confidentiality.
  Security tokens are also sometimes described as Assertions, such as in
  <xref target="RFC7521"/>.
</t>

<t>
  A Security Token Service (STS) is a service capable of validating and issuing
  security tokens, which enables clients to obtain appropriate
  access credentials for resources in heterogeneous environments or across security
  domains.
  Web Service clients have used <xref target="WS-Trust">WS-Trust</xref>
  as the protocol to interact with an STS for token exchange,
  however WS-Trust is a fairly heavyweight protocol, which uses XML, SOAP, etc.
  Whereas, the trend in modern Web development
  has been towards lightweight services utilizing RESTful patterns and JSON.
  <xref target="RFC6749">The OAuth 2.0 Authorization Framework</xref>
  and <xref target="RFC6750">OAuth 2.0 Bearer Tokens</xref>
  have emerged as popular standards for authorizing and securing access to HTTP and
  RESTful resources but do not provide everything necessary to facilitate
  token exchange interactions.
</t>
<t>
  This specification defines a lightweight protocol extending OAuth 2.0 that enables
  clients to request and obtain security tokens from authorization servers acting in
  the role of an STS.
  Similar to OAuth 2.0, this specification focuses on client developer simplicity and
  requires only an HTTP client and JSON parser, which are nearly universally available
  in modern development environments. The STS protocol defined in this specification
  is not itself RESTful (an STS doesn't lend itself particularly well to a REST
  approach) but does utilize communication patterns and data formats that should be
  familiar to developers accustomed to working with RESTful systems.
</t>
<t>
  A new grant type for a token exchange request and the associated specific parameters for
  such a request to the token endpoint are defined by this specification.
  A token exchange response is a normal OAuth 2.0 response from the token endpoint
  with a few additional parameters defined herein to provide information to the client.
</t>
<t>
  The entity that makes the request to exchange tokens is considered the client in the
  context of the token exchange interaction. However, that does not restrict
  usage of this profile to traditional OAuth clients. An OAuth resource server, for example,
  might assume the role of the client during token exchange in order to trade an access token,
  which it received in a protected resource request, for a new token that is appropriate to include in a
  call to a backend service. The new token might be an access token that is more
  narrowly scoped for the downstream service or it could be an entirely different kind
  of token.
</t>
<t>
  The scope of this specification is limited to the definition of a
  basic request and response protocol for an STS-style token exchange utilizing OAuth 2.0.
  Although a few new JWT claims are defined that enable delegation semantics to be expressed,
  the specific syntax, semantics and security characteristics of the tokens themselves
  (both those presented to the AS and those obtained by the client)
  are explicitly out of scope and no requirements are placed on the trust model in
  which an implementation might be deployed. Additional profiles may provide
  more detailed requirements around the specific nature of the parties and trust involved,
  such as whether signing and/or encryption of tokens is required; however, such details
  will often be policy decisions made with respect to the specific needs of individual
  deployments and will be configured or implemented accordingly.
</t>
<t>
  The security tokens obtained could be used in a number of contexts,
  the specifics of which are also beyond the scope of this specification.
</t>

      <section anchor="DelegationImpersonation" title="Delegation vs. Impersonation Semantics">

  <t>
    When principal A impersonates principal B, A is given all
    the rights that B has within some defined rights context
    and is indistinguishable from B in that context.
    Thus, when principal A impersonates principal B, then in
    so far as any entity receiving such a token is concerned, they are
    actually dealing with B. It is true that some members of the
    identity system might have awareness that impersonation is
    going on, but it is not a requirement. For all intents and
    purposes, when A is impersonating B, A is B.
  </t>
  <t>
    Delegation semantics are different than
    impersonation semantics, though the two are closely related.
    With delegation semantics, principal A still has its own identity
    separate from B and it is explicitly understood that while B
    may have delegated some of its rights to A, any actions taken are
    being taken by A representing B. In a sense, A is an agent for B.
  </t>
  <t>
    Delegation and impersonation are not inclusive of all situations.
    When a principal is acting directly on its own behalf, for example,
    neither delegation nor impersonation are in play. They are, however,
    the more common semantics operating for token exchange and, as such, are
    given more direct treatment in this specification.
  </t>
  <t>
    Delegation semantics are typically expressed in a token by including information about both the
    primary subject of the token as well as the actor to whom that subject has delegated some of its rights.
    Such a token is sometimes referred to as a composite token because it is composed of information
    about multiple subjects. A client can indicate the desire for a
    composite token by including a <spanx style="verb">want_composite</spanx> parameter in the request with the value
    <spanx style="verb">true</spanx>. Typically, in the request, the <spanx style="verb">subject_token</spanx>
    represents the identity of the party on
    behalf of whom the token is being requested while the <spanx style="verb">actor_token</spanx> represents
    the identity of the party to whom the access rights of the issued token are being delegated.
    A composite token issued by the authorization server will contain information about both parties.
  </t>
  <t>
    The specifics of representing a composite token and even whether or not such a token will be issued depend on the details of the implementation and the kind of token.
    The representations of composite tokens that are not JWTs are beyond the scope of this specification.
    The <xref target="actor"/> request parameter, however, does provide a means
    for providing information about the desired actor though the representation
    of a chain of delegation using the JWT <spanx style="verb">act</spanx> claim.
  </t>
      </section>

      <section anchor="RNC" title="Requirements Notation and Conventions">
	<t>
	  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
	  "SHOULD", "SHOULD NOT", "RECOMMENDED", "NOT RECOMMENDED", "MAY", and "OPTIONAL"
	  in this document are to be interpreted as described in
	  <xref target="RFC2119">RFC 2119</xref>.
	</t>
      </section>

      <section anchor="Terminology" title="Terminology">
        <t>
	  This specification uses the terms
	  "access token type", "authorization server", "client", "client identifier",
	  "resource server", "token endpoint", "token request", and "token response"
	  defined by <xref target="RFC6749">OAuth 2.0</xref>,
	  and the terms "Claim" and "JWT Claims Set" defined by
	  <xref target="JWT">JSON Web Token (JWT)</xref>.
        </t>
      </section>

    </section>

    <section anchor="Messages" title="Token Exchange Request and Response">
    <section title="Request" anchor="Request">
<t>
  A client requests a security token by making a token request to the authorization
  server's token endpoint using the extension grant type mechanism defined
  in Section 4.5 of <xref target="RFC6749">OAuth 2.0</xref>.
</t>
<t>
  Client authentication to the authorization server is done using the normal
  mechanisms provided by OAuth 2.0.
  Section 2.3.1 of <xref target="RFC6749">The OAuth 2.0 Authorization Framework</xref>
  defines password-based authentication of the client,
  however, client authentication is extensible and other mechanisms are possible.
  For example, <xref target="RFC7523"/> defines client authentication using
  JSON Web Tokens (JWTs) <xref target="JWT"/>.
  The supported methods of client authentication and whether or not to allow
  unauthenticated or unidentified clients are deployment decisions that are
  at the discretion of the authorization server.
</t>
<t>
  The client makes a token exchange request to the token endpoint with an extension
  grant type by including the
  following parameters using the <spanx style='verb'>application/x-www-form-urlencoded</spanx>
  format with a character encoding of UTF-8 in the HTTP request entity-body:
</t>
<t>
<list style="hanging">

  <t hangText="grant_type">
    <vspace/>
    REQUIRED. The value
    <spanx style='verb'>urn:ietf:params:oauth:grant-type:token-exchange</spanx>
    indicates that a token exchange is being performed.
  </t>

  <t hangText="resource">
    <vspace/>
    OPTIONAL.
    Indicates the physical location of the target service or resource where the client intends to use
    the requested security token. This enables the authorization server to apply policy as appropriate
    for the target, such as determining the type and content of the token to be issued or if and how
    the token is to be encrypted.
    In many cases, a client will not have knowledge of the logical organization of the systems with
    which it interacts and will only know the location of the service where it intends to use the token.
    The <spanx style="verb">resource</spanx> parameter allows the client to indicate to the authorization server
    where it intends to use the issued token by providing the location, typically as an https URL, in the
    token exchange request in the same form that will be used to access that resource.
    The authorization server will typically have the capability to map from a resource URI value to
    an appropriate policy. The value of the <spanx style="verb">resource</spanx> parameter MUST be an
    absolute URI, as specified by Section 4.3 of <xref target="RFC3986"/>,
    which MAY include a query component and MUST NOT include a fragment component.
    Multiple <spanx style="verb">resource</spanx> parameters may be used to indicate
    that the issued token is intended to be used at the multiple resources listed.
  </t>

  <t hangText="audience">
    <vspace/>
    OPTIONAL.
    The logical name of the target service where the client intends to use
    the requested security token. This serves a purpose similar to the
    <spanx style="verb">resource</spanx> parameter, but with the client providing a logical name
    rather than a physical location. Interpretation of the name requires that the value be something
    that both the client and the authorization server understand. An OAuth client identifier,
    a SAML entity identifier  <xref target="OASIS.saml-core-2.0-os"/>,
    an OpenID Connect Issuer Identifier <xref target="OpenID.Core"/>,
    or a URI are examples of things that
    might be used as <spanx style="verb">audience</spanx> parameter values.
    Multiple <spanx style="verb">audience</spanx> parameters may be used to indicate
    that the issued token is intended to be used at the multiple audiences listed.
    The <spanx style="verb">audience</spanx> and <spanx style="verb">resource</spanx> parameters may
    be used together to indicate multiple target services with a mix of logical names and physical locations.
  </t>

  <t hangText="scope">
    <vspace/>
    OPTIONAL.
    A list of space-delimited, case-sensitive strings that allow the client to
    specify the desired scope of the requested security token in the context of the
    service or resource where the token will be used.</t>

  <t hangText="requested_token_type">
    <vspace/>
    OPTIONAL.
    An identifier, as described in <xref target="TokenTypeIdentifiers"/>, for the type of the requested security token.
    For example, a JWT can be requested with the identifier
    <spanx style="verb">urn:ietf:params:oauth:token-type:jwt</spanx>.
    If the requested type is unspecified, the issued token type is at
    the discretion of the authorization server and may be dictated by
    knowledge of the requirements of the service or resource
    indicated by the <spanx style='verb'>resource</spanx> or
    <spanx style="verb">audience</spanx> parameter.
  </t>

  <t hangText="subject_token">
    <vspace/>
    REQUIRED.
    A security token that represents the
    identity of the party on behalf of whom the request is being made.
    Typically the subject of this token will be the subject of
    the security token issued in response to this request.
  </t>

  <t hangText="subject_token_type">
    <vspace/>
    REQUIRED.
    An identifier, as described in <xref target="TokenTypeIdentifiers"/>, that indicates the type of the security token in
    the <spanx style="verb">subject_token</spanx> parameter. For example,
    a value of <spanx style="verb">urn:ietf:params:oauth:token-type:jwt</spanx>,
    would indicate that the token is a JWT and a value of
    <spanx style="verb">urn:ietf:params:oauth:token-type:access_token</spanx>
    would indicate that the token is an OAuth access token.
  </t>

  <t hangText="actor_token">
    <vspace/>
    OPTIONAL.
    A security token that represents
    the identity of the party that is authorized to use the requested security token and act on behalf of the subject.
  </t>

  <t hangText="actor_token_type">
    <vspace/>
    An identifier, as described in <xref target="TokenTypeIdentifiers"/>, that indicates the type of the security token in the
    <spanx style="verb">actor_token</spanx> parameter.
    This is REQUIRED when the <spanx style="verb">actor_token</spanx> parameter
    is present in the request but MUST NOT be included otherwise.
  </t>

  <t hangText="want_composite">
    <vspace/>
    OPTIONAL.
    When the value of this parameter is <spanx style="verb">true</spanx>, it indicates the client's desire
    for a composite security token to be issued, which contains claims about both the main subject of the
    token as well as about the party who is authorized to act on behalf of that subject. Note that this
    parameter only provides a means for the client to indicate its preference. The authorization server
    is not required to honor the stated preference and the nature of the tokens it issues are ultimately at
    its discretion.
  </t>
</list>
</t>

    </section>

    <section title="Response" anchor="Response">
<t>
  The authorization server responds to a token exchange request with a normal
  OAuth 2.0 response from the token endpoint, as specified in
  Section 5 of <xref target="RFC6749"/>. Additional details and
  explanation are provided in the following subsections.
</t>
      <section title="Successful Response" anchor="SuccessfulResponse">
<t>
  If the request is valid and meets all policy and other criteria of the authorization server,
  a successful token response is constructed by adding the following parameters
  to the entity-body of the HTTP response using the "application/json"
  media type, as specified by <xref target="RFC7159"/>, and an HTTP 200 status code.  The
  parameters are serialized into a JavaScript Object Notation (JSON)
  structure by adding each parameter at the top level.
  Parameter names and string values are included as JSON strings.
  Numerical values are included as JSON numbers.  The order of
  parameters does not matter and can vary.
</t>
        <t>
          <list style="hanging">

<t hangText="access_token">
  <vspace/>
  REQUIRED. The security token issued by the authorization server in response
  to the token exchange request.
  The <spanx style="verb">access_token</spanx> parameter from
  Section 5.1 of <xref target="RFC6749"/> is used here to carry the requested
  token, which allows this token exchange protocol to use the existing OAuth 2.0 request
  and response constructs defined for the token endpoint.
  The identifier <spanx style="verb">access_token</spanx> is used for historical
  reasons and the issued token need not be an OAuth access token.
</t>

<t hangText="issued_token_type">
  <vspace/>
  REQUIRED.  An identifier, as described in <xref target="TokenTypeIdentifiers"/>,
  for the representation of the issued security token.
  For example, a value of <spanx style="verb">urn:ietf:params:oauth:token-type:access_token</spanx>
  indicates that the issued token is an access token and a value of
  <spanx style="verb">urn:ietf:params:oauth:token-type:jwt</spanx> indicates that it is a JWT.
</t>

<t hangText="token_type">
  <vspace/>
  REQUIRED.
  A case-insensitive value specifying the method of using of the access token issued,
  as specified in Section 7.1 of <xref target="RFC6749"/>.
  It provides the client
  with information about how to utilize the access token to access protected resources.
  For example, a value of <spanx style="verb">Bearer</spanx>,
  as specified in <xref target="RFC6750"/>, indicates that
  the security token is a bearer token and the client can simply present it as is without any
  additional proof of eligibility beyond the contents of the token itself.
  <!-- pop-key-distribution is very much in flux and doesn't define the "PoP" identifier
       used below, other than in examples.  We should not take a dependence on this spec.
  A value of <spanx style="verb">PoP</spanx>, on the other hand, indicates that use of
  the token will require demonstrating possession of a cryptographic key associated with the
  security token (<xref target="I-D.ietf-oauth-pop-key-distribution"/> describes the
  <spanx style="verb">PoP</spanx> token type).
  -->
  Note that the meaning of this parameter is different from the meaning of
  the <spanx style="verb">issued_token_type</spanx> parameter,
  which declares the representation of the issued security token;
  the term "token type" is typically used with this meaning, as it is in
  all <spanx style="verb">*_token_type</spanx> parameters in this specification.
  If the issued token is not an access token or usable as an access token,
  then the <spanx style="verb">token_type</spanx> value <spanx style="verb">N_A</spanx> is used
  to indicate that an OAuth 2.0
  <spanx style="verb">token_type</spanx> identifier is not applicable in that context.
</t>

<t hangText="expires_in">
  <vspace/>
  RECOMMENDED.  The validity lifetime, in seconds, of the token issued by the
  authorization server. Oftentimes the client will not have the inclination or capability
  to inspect the content of the token and this parameter provides a consistent and token type
  agnostic indication of how long the token can be expected to be valid.
  For example, the value 1800 denotes that the token will
  expire in thirty minutes from the time the response was generated.
</t>

<t hangText="scope">
  <vspace/>
  OPTIONAL, if the scope of the issued security token is identical to the scope requested by the client;
  otherwise, REQUIRED.
</t>

<t hangText="refresh_token">
  <vspace/>
  NOT RECOMMENDED.
  Refresh tokens will typically not be issued in response to
  <spanx style="verb">urn:ietf:params:oauth:grant-type:token-exchange</spanx>
  grant type requests. Profiles or deployments of this specification that do
  issue refresh tokens SHOULD clearly document the conditions and reasons for doing so.
</t>

        </list>
        </t>
      </section>
      <section anchor="ErrorResponse" title="Error Response">
  <t>
    If either the <spanx style="verb">subject_token</spanx> or <spanx style="verb">actor_token</spanx>
    are invalid for any reason, or are unacceptable based on policy, the authorization server
    MUST construct an error response, as specified in Section 5.2 of <xref target="RFC6749"/>.
    The value of the <spanx style='verb'>error</spanx>
    parameter MUST be the <spanx style='verb'>invalid_request</spanx> error code. The authorization
    server MAY include additional information regarding the reasons for the error
    using the <spanx style='verb'>error_description</spanx> and/or <spanx style='verb'>error_uri</spanx> parameters.
    Other error codes may also be used, as appropriate.
  </t>
      </section>


    </section>

<section title="Example Token Exchange" anchor="MainExample">
<t>
  The following example demonstrates a hypothetical token exchange in which
  an OAuth resource server
  assumes the role of the client during token exchange in order to
  trade an access token that it received in a request for a
  token that it will use to call to a backend service
  (extra line breaks and indentation in the examples are for display purposes only).
</t>
<t>
  The resource server receives the following request containing
  an OAuth access token in the Authorization request header, as specified in
  Section 2.1 of <xref target="RFC6750"/>.
</t>

<figure title="Protected Resource Request" anchor="main-prr">
  <artwork><![CDATA[
 GET /resource HTTP/1.1
 Host: frontend.example.com
 Authorization: Bearer accVkjcJyb4BWCxGsndESCJQbdFMogUC5PbRDqceLTC
]]></artwork>
</figure>

<t>
  The resource server assumes the role of the client for the token exchange
  and the access token from the request above is sent
  to the authorization
  server using a request as specified in <xref target="Request"/>.
  The value of the <spanx style="verb">subject_token</spanx> parameter carries the
  access token and the value of
  the <spanx style="verb">subject_token_type</spanx> parameter indicates that it is
  an OAuth 2.0 access token.
  The resource server, acting as the client, uses its identifier and secret to authenticate to
  the authorization server using the HTTP Basic authentication scheme.
  The <spanx style="verb">resource</spanx> parameter indicates the location
  of the backend service, https://backend.example.com/api,
  where the issued token will be used.
</t>

<figure title="Token Exchange Request" anchor="main-tereq">
  <artwork><![CDATA[
 POST /as/token.oauth2 HTTP/1.1
 Host: as.example.com
 Authorization: Basic cnMwODpsb25nLXNlY3VyZS1yYW5kb20tc2VjcmV0
 Content-Type: application/x-www-form-urlencoded

 grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Atoken-exchange
 &resource=https%3A%2F%2Fbackend.example.com%2Fapi%20
 &subject_token=accVkjcJyb4BWCxGsndESCJQbdFMogUC5PbRDqceLTC
 &subject_token_type=
  urn%3Aietf%3Aparams%3Aoauth%3Atoken-type%3Aaccess_token
]]></artwork>
</figure>

<t>
  The authorization server validates the client credentials and the
  <spanx style="verb">subject_token</spanx> presented in the token
  exchange request. From the <spanx style="verb">resource</spanx>
  parameter, the authorization server is able to determine the
  appropriate policy to apply to the request and issues a token
  suitable for use at https://backend.example.com.
  The <spanx style="verb">access_token</spanx> parameter of the
  response contains the new token, which is itself a bearer OAuth
  access token that is valid for one minute. The token happens to be
  a JWT; however, its structure and format are opaque to
  the client so the <spanx style="verb">issued_token_type</spanx>
  indicates only that it is an access token.
</t>

  <figure title="Token Exchange Response" anchor="main-teresp">
    <artwork><![CDATA[
 HTTP/1.1 200 OK
 Content-Type: application/json
 Cache-Control: no-cache, no-store

 {
  "access_token":"eyJhbGciOiJFUzI1NiIsImtpZCI6IjllciJ9.eyJhdWQiOiJo
    dHRwczovL2JhY2tlbmQuZXhhbXBsZS5jb20iLCJpc3MiOiJodHRwczovL2FzLmV
    4YW1wbGUuY29tIiwiZXhwIjoxNDQxOTE3NTkzLCJpYXQiOjE0NDE5MTc1MzMsIm
    F6cCI6InJzMDgiLCJzdWIiOiJiY0BleGFtcGxlLmNvbSIsInNjcCI6WyJhcGkiX
    X0.vHJKtJ-zFIN75Tk7qGlmQsWPlvnChb2uSaGwPLvlWl64ts7-vvfwYDaVoXIQ
    e_HkTVdljIzavVlPT60_b_9pDQ",
  "issued_token_type":
      "urn:ietf:params:oauth:token-type:access_token",
  "token_type":"Bearer",
  "expires_in":60
 }
]]></artwork>
  </figure>

<t>
  The resource server can then use the newly acquired access token in making
  a request to the backend server.
</t>

      <figure title="Backend Protected Resource Request" anchor="main-beprr">
        <artwork><![CDATA[
 GET /api HTTP/1.1
 Host: backend.example.com
 Authorization: Bearer eyJhbGciOiJFUzI1NiIsImtpZCI6IjllciJ9.eyJhdWQ
    iOiJodHRwczovL2JhY2tlbmQuZXhhbXBsZS5jb20iLCJpc3MiOiJodHRwczovL2
    FzLmV4YW1wbGUuY29tIiwiZXhwIjoxNDQxOTE3NTkzLCJpYXQiOjE0NDE5MTc1M
    zMsImF6cCI6InJzMDgiLCJzdWIiOiJiY0BleGFtcGxlLmNvbSIsInNjcCI6WyJh
    cGkiXX0.vHJKtJ-zFIN75Tk7qGlmQsWPlvnChb2uSaGwPLvlWl64ts7-vvfwYDa
    VoXIQe_HkTVdljIzavVlPT60_b_9pDQ
]]></artwork>
      </figure>

  <!--    JWT signing key
  {"kty":"EC","kid":"9er","use":"sig","alg":"ES256",
  "x":"5yoR9FjZHn7kJDALhDzhZ8i8F06mc12YswUMTBv4BoA",
  "y":"4uxuIItWj5Duzspth5mUbpLXWrPFzFPQkOCeAGGI6KM",
  "crv":"P-256",
  "d":"LncS7zrx6c8X5qZRxoSN18ZEYDeI2wfKfUvX_DgwRH8"}
  -->
  <t>
    Additional examples can be found in <xref target="AdditionalExamples"/>.
  </t>
</section>
    </section>
    <section anchor="TokenTypeIdentifiers" title="Token Type Identifiers">
<t>
  Several parameters in this specification utilize an identifier as the value to
  describe the type of token in question. Specifically, they are the
  <spanx style="verb">requested_token_type</spanx>,
  <spanx style="verb">subject_token_type</spanx>, <spanx style="verb">actor_token_type</spanx>
  parameters of the request and the <spanx style="verb">issued_token_type</spanx> member of the response.
  Token type identifiers are URIs.
</t>
<t>
  This specification defines the token type identifiers
  <spanx style="verb">urn:ietf:params:oauth:token-type:access_token</spanx> and
  <spanx style="verb">urn:ietf:params:oauth:token-type:refresh_token</spanx> to indicate
  that the token is an OAuth 2.0 access token or refresh token, respectively.
  The value <spanx style="verb">urn:ietf:params:oauth:token-type:jwt</spanx> defined in
  Section 9 of <xref target="JWT"/> indicates that the token is a JWT.
  Other URIs to indicate other token types MAY be used.
</t>
   </section>

    <section title="JSON Web Token Claims" anchor="JWTClaims">
 <t>
   It is useful to have defined mechanisms to express delegation within a token as well as to express
   authorization to delegate or impersonate. Although the token exchange protocol described
   herein can be used with any type of token, this section defines claims to express such
   semantics specifically for JWTs.
   Similar definitions for other types of tokens are possible but
   beyond the scope of this specification.
 </t>
  <section title='"act" (Actor) Claim' anchor="actor">
    <t>
      The <spanx style="verb">act</spanx> (actor) claim provides a means within a JWT
      to express that delegation has occurred and identify the acting party to whom authority has been delegated.
      The <spanx style="verb">act</spanx> claim value is a JSON object and
      members in the JSON object are claims that identify the actor.
      The claims that make up the <spanx style="verb">act</spanx>
      claim identify and possibly provide additional information about the actor.
      For example, the combination of the two claims <spanx style="verb">iss</spanx>
      and <spanx style="verb">sub</spanx> might be necessary to uniquely identify an actor.
    </t>
    <t>
      However, claims within the <spanx style="verb">act</spanx> claim pertain only to the identity of the actor
      and are not relevant to the validity of the containing JWT in the same manner as the top-level claims.
      Consequently, claims such as <spanx style="verb">exp</spanx>, <spanx style="verb">nbf</spanx>, and
      <spanx style="verb">aud</spanx> are not meaningful when used within an <spanx style="verb">act</spanx>
      claim, and therefore should not be used.
    </t>

    <figure title="Actor Claim" anchor="act-ex">
      <preamble>
        The following example illustrates the <spanx style="verb">act</spanx> (actor) claim within a JWT Claims Set.
        The claims of the token itself are about user@example.com while the <spanx style="verb">act</spanx> claim indicates
        that admin@example.com is the current actor.
      </preamble>
    <artwork><![CDATA[
 {
   "aud":"https://consumer.example.com",
   "iss":"https://issuer.example.com",
   "exp":1443904177,
   "nbf":1443904077,
   "sub":"user@example.com",
   "act":
   {
     "sub":"admin@example.com"
   }
 }
]]></artwork>
    </figure>

    <t>
      A chain of delegation can be expressed by nesting one <spanx style="verb">act</spanx> claim within
      another. The outermost <spanx style="verb">act</spanx> claim represents the current actor while nested
      <spanx style="verb">act</spanx> claims represent prior actors. The least recent actor is the most deeply
      nested.
    </t>
    <figure title="Nested Actor Claim" anchor="acts-ex">
      <preamble>
        The following example illustrates nested <spanx style="verb">act</spanx> (actor) claims within a JWT Claims Set.
        The claims of the token itself are about user@example.com while the <spanx style="verb">act</spanx> claim indicates
        that the system consumer.example.com-web-application is the current actor and admin@example.com was a prior actor. Such a token
        might come about as the result of the web application receiving a token like the one in the previous example
        and exchanging it for a new token that lists it as the current actor and that can be used at https://backend.example.com.
      </preamble>
      <artwork><![CDATA[
 {
   "aud":"https://backend.example.com",
   "iss":"https://issuer.example.com",
   "exp":1443904100,
   "nbf":1443904000,
   "sub":"user@example.com",
   "act":
   {
     "sub":"consumer.example.com-web-application",
     "iss":"https://issuer.example.net",
     "act":
     {
       "sub":"admin@example.com"
     }
   }
 }
]]></artwork>
    </figure>
  </section>
  <section title='"scp" (Scopes) Claim' anchor="scopes">
    <t>
      The <spanx style="verb">scp</spanx> claim is an array of strings, each of which
      represents an OAuth scope granted for the issued security token.
      Each array entry of the claim value is a scope-token, as defined in
      Section 3.3 of <xref target="RFC6749">OAuth 2.0</xref>.
    </t>

    <figure title="Scopes Claim" anchor="scp-ex">
      <preamble>
        The following example illustrates the <spanx style="verb">scp</spanx> claim within a JWT Claims Set with
        four scope-tokens.
      </preamble>
      <artwork><![CDATA[
 {
   "aud":"https://consumer.example.com",
   "iss":"https://issuer.example.com",
   "exp":1443904177,
   "nbf":1443904077,
   "sub":"dgaf4mvfs75Fci_FL3heQA",
   "scp":["email","address","profile","phone"]
 }
]]></artwork>
    </figure>
  </section>

  <section title='"may_act" (May Act For) Claim' anchor="may_act">
    <t>
      The <spanx style="verb">may_act</spanx> claim makes a statement that one party is authorized to
      become the actor and act on behalf of another party.
      The claim value is a JSON object and members in the JSON object are claims that identify the party that
      is asserted as being eligible to act for the party identified by
      the JWT containing the claim.
      The claims that make up the <spanx style="verb">may_act</spanx>
      claim identify and possibly provide additional information about the authorized actor.
      For example, the combination of the two claims <spanx style="verb">iss</spanx>
      and <spanx style="verb">sub</spanx> are sometimes necessary to uniquely identify an authorized actor,
      while the <spanx style="verb">email</spanx> claim might be used to provide additional useful information about
      that party.
    </t>
    <t>
      However, claims within the <spanx style="verb">may_act</spanx> claim pertain only to the identity of that party
      and are not relevant to the validity of the containing JWT
      in the same manner as top level claims.
      Consequently, claims such as <spanx style="verb">exp</spanx>, <spanx style="verb">nbf</spanx>, and
      <spanx style="verb">aud</spanx> are not meaningful when used within a <spanx style="verb">may_act</spanx>
      claim, and therefore should not be used.
    </t>

    <figure title="May Act For Claim" anchor="may_act-ex">
      <preamble>
        The following example illustrates the <spanx style="verb">may_act</spanx> claim within a JWT Claims Set.
        The claims of the token itself are about user@example.com while the <spanx style="verb">may_act</spanx> claim indicates
        that admin@example.com is authorized to act on behalf of user@example.com.
      </preamble>
      <artwork><![CDATA[
 {
   "aud":"https://consumer.example.com",
   "iss":"https://issuer.example.com",
   "exp":1443904177,
   "nbf":1443904077,
   "sub":"user@example.com",
   "may_act":
   {
     "sub":"admin@example.com"
   }
 }
]]></artwork>
    </figure>
  </section>

    </section>

    <section anchor="IANA" title="IANA Considerations">

      <section anchor="URIReg" title="OAuth URI Registration">

	<t>
	  This specification registers the following values in the
	  IANA "OAuth URI" registry
	  <xref target="IANA.OAuth.Parameters"/>
	  established by <xref target="RFC6755"/>.
	</t>

	<section title="Registry Contents" anchor="URIContents">

	  <t>
	    <?rfc subcompact="yes"?>
	    <list style="symbols">
	      <t>URN: urn:ietf:params:oauth:grant-type:token-exchange</t>
	      <t>Common Name: Token exchange grant type for OAuth 2.0</t>
	      <t>Change controller: IESG</t>
	      <t>Specification Document: <xref target="Request"/> of [[ this specification ]]</t>
	    </list>
	  </t>
	  <t>
	    <list style="symbols">
	      <t>URN: urn:ietf:params:oauth:token-type:access_token</t>
	      <t>Common Name: Token type URI for an OAuth 2.0 access token</t>
	      <t>Change controller: IESG</t>
	      <t>Specification Document: <xref target="TokenTypeIdentifiers"/> of [[this specification]]</t>
	    </list>
	  </t>
	  <t>
	    <list style="symbols">
	      <t>URN: urn:ietf:params:oauth:token-type:refresh_token</t>
	      <t>Common Name: Token Type URI for an OAuth 2.0 refresh token</t>
	      <t>Change controller: IESG</t>
	      <t>Specification Document: <xref target="TokenTypeIdentifiers"/> of [[this specification]]</t>
	    </list>

	  </t>
	  <?rfc subcompact="no"?>

	</section>
      </section>

      <section anchor="OAuthParametersReg" title="OAuth Parameters Registration">

	<t>
	  This specification registers the following values
	  in the IANA "OAuth Parameters" registry
	  <xref target="IANA.OAuth.Parameters"/>
	  established by <xref target="RFC6749"/>.
	</t>

	<section anchor='ParametersContents' title='Registry Contents'>

	  <t>
	    <?rfc subcompact="yes"?>
	    <list style='symbols'>
	      <t>Parameter name: resource</t>
	      <t>Parameter usage location: token request</t>
	      <t>Change controller: IESG</t>
	      <t>Specification document(s): <xref target="Request"/> of [[ this specification ]]</t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>Parameter name: audience</t>
	      <t>Parameter usage location: token request</t>
	      <t>Change controller: IESG</t>
	      <t>Specification document(s): <xref target="Request"/> of [[ this specification ]]</t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>Parameter name: requested_token_type</t>
	      <t>Parameter usage location: token request</t>
	      <t>Change controller: IESG</t>
	      <t>Specification document(s): <xref target="Request"/> of [[ this specification ]]</t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>Parameter name: subject_token</t>
	      <t>Parameter usage location: token request</t>
	      <t>Change controller: IESG</t>
	      <t>Specification document(s): <xref target="Request"/> of [[ this specification ]]</t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>Parameter name: subject_token_type</t>
	      <t>Parameter usage location: token request</t>
	      <t>Change controller: IESG</t>
	      <t>Specification document(s): <xref target="Request"/> of [[ this specification ]]</t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>Parameter name: actor_token</t>
	      <t>Parameter usage location: token request</t>
	      <t>Change controller: IESG</t>
	      <t>Specification document(s): <xref target="Request"/> of [[ this specification ]]</t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>Parameter name: actor_token_type</t>
	      <t>Parameter usage location: token request</t>
	      <t>Change controller: IESG</t>
	      <t>Specification document(s): <xref target="Request"/> of [[ this specification ]]</t>
	    </list>
	  </t>
    <t>
      <list style='symbols'>
        <t>Parameter name: want_composite</t>
        <t>Parameter usage location: token request</t>
        <t>Change controller: IESG</t>
        <t>Specification document(s): <xref target="Request"/> of [[ this specification ]]</t>
      </list>
    </t>
	  <t>
	    <list style='symbols'>
	      <t>Parameter name: issued_token_type</t>
	      <t>Parameter usage location: token response</t>
	      <t>Change controller: IESG</t>
	      <t>Specification document(s): <xref target="SuccessfulResponse"/> of [[ this specification ]]</t>
	    </list>
	  </t>
	  <?rfc subcompact="no"?>

	</section>
      </section>

      <section anchor="TokenTypeReg" title='OAuth Access Token Type Registration'>

        <t>
          This specification registers the following access token type
	  in the IANA "OAuth Access Token Types" registry
	  <xref target="IANA.OAuth.Parameters"/>
	  established by <xref target="RFC6749"/>.
        </t>

        <section anchor="TokenTypeContents" title='Registry Contents'>

          <t>
	    <?rfc subcompact="yes"?>
            <list style='symbols'>
              <t>Type name: N_A</t>
              <t>Additional Token Endpoint Response Parameters: (none)</t>
              <t>HTTP Authentication Scheme(s): (none)</t>
              <t>Change controller: IESG</t>
              <t>Specification document(s): <xref target="SuccessfulResponse"/> of [[ this specification ]]</t>
            </list>
          </t>
	  <?rfc subcompact="no"?>

        </section>
      </section>

      <section anchor="ClaimsReg" title="JSON Web Token Claims Registration">

	<t>
	  This specification registers the following Claims
	  in the IANA "JSON Web Token Claims" registry
	  <xref target="IANA.JWT.Claims"/>
	  established by <xref target="JWT"/>.
	</t>

	<section anchor='ClaimsContents' title='Registry Contents'>

	  <t>
	    <?rfc subcompact="yes"?>
	    <list style='symbols'>
	      <t>Claim Name: <spanx style="verb">act</spanx></t>
	      <t>Claim Description: Actor</t>
	      <t>Change Controller: IESG</t>
	      <t>Specification Document(s): <xref target="actor"/> of [[ this specification ]]</t>
	    </list>
	  </t>
	  <t>
	    <list style='symbols'>
	      <t>Claim Name: <spanx style="verb">scp</spanx></t>
	      <t>Claim Description: Scope Values</t>
	      <t>Change Controller: IESG</t>
	      <t>Specification Document(s): <xref target="scopes"/> of [[ this specification ]]</t>
	    </list>
	  </t>
    <t>
      <list style='symbols'>
        <t>Claim Name: <spanx style="verb">may_act</spanx></t>
        <t>Claim Description: May Act For</t>
        <t>Change Controller: IESG</t>
        <t>Specification Document(s): <xref target="may_act"/> of [[ this specification ]]</t>
      </list>
    </t>
	  <?rfc subcompact="no"?>

	</section>
      </section>

    </section>

    <section anchor="Security" title="Security Considerations">
      <t>
        All of the normal security issues that are discussed in <xref target="JWT"/>,
	especially in relationship to comparing URIs and dealing with unrecognized values,
	also apply here.
      </t>
      <t>
        In addition, both delegation and impersonation introduce unique security
        issues.  Any time one principal is delegated the rights of
        another principal, the potential for abuse is a concern.
	The use of the <spanx style="verb">scp</spanx> claim is suggested to mitigate
	potential for such abuse, as it restricts the contexts in which
	the delegated rights can be exercised.
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml' ?>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6749.xml' ?>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml' ?>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7159.xml' ?>


      <reference anchor="JWT" target="http://tools.ietf.org/html/rfc7519">
	<front>
	  <title>JSON Web Token (JWT)</title>

	  <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
	    <organization abbrev="Microsoft">Microsoft</organization>
	  </author>

	  <author fullname="John Bradley" initials="J." surname="Bradley">
	    <organization abbrev="Ping Identity">Ping Identity</organization>
	  </author>

	  <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
	    <organization abbrev="NRI">Nomura Research Institute, Ltd.</organization>
	  </author>

	  <date month="May" year="2015" />
	</front>

	<seriesInfo name="RFC" value="7519"/>
	<seriesInfo name="DOI" value="10.17487/RFC7519"/>
      </reference>

      <reference anchor="IANA.JWT.Claims" target="http://www.iana.org/assignments/jwt">
        <front>
          <title>JSON Web Token Claims</title>
          <author>
            <organization>IANA</organization>
          </author>
	  <date/>
        </front>
      </reference>

      <reference anchor="IANA.OAuth.Parameters" target="http://www.iana.org/assignments/oauth-parameters">
        <front>
          <title>OAuth Parameters</title>
          <author>
            <organization>IANA</organization>
          </author>
	  <date/>
        </front>
      </reference>

    </references>

    <references title="Informative References">
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6755.xml' ?>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6750.xml' ?>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7521.xml' ?>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7523.xml' ?>
      <!-- <?rfc include="reference.I-D.ietf-oauth-pop-key-distribution"?> -->

      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml2/reference.OASIS.saml-core-2.0-os.xml' ?>

      <reference anchor="WS-Trust" target="http://docs.oasis-open.org/ws-sx/ws-trust/v1.4/ws-trust.html">
        <front>
          <title>WS-Trust 1.4</title>
          <author fullname="Anthony Nadalin" initials="A." surname="Nadalin"/>
          <author fullname="Marc Goodner" initials="M." surname="Goodner"/>
          <author fullname="Martin Gudgin" initials="M." surname="Gudgin"/>
          <author fullname="Abbie Barbir" initials="A." surname="Barbir"/>
          <author fullname="Hans Granqvist" initials="H." surname="Granqvist"/>
          <date day="2" month="February" year="2012"/>
        </front>
      </reference>

      <reference anchor="OpenID.Core" target="http://openid.net/specs/openid-connect-core-1_0.html">
        <front>
          <title>OpenID Connect Core 1.0</title>

          <author fullname="Nat Sakimura" initials="N." surname="Sakimura">
            <organization abbrev="NRI">Nomura Research Institute, Ltd.</organization>
          </author>

          <author fullname="John Bradley" initials="J." surname="Bradley">
            <organization abbrev="Ping Identity">Ping Identity</organization>
          </author>

          <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
            <organization abbrev="Microsoft">Microsoft</organization>
          </author>

          <author fullname="Breno de Medeiros" initials="B." surname="de Medeiros">
            <organization abbrev="Google">Google</organization>
          </author>

	  <author fullname="Chuck Mortimore" initials="C." surname="Mortimore">
	    <organization abbrev="Salesforce">Salesforce</organization>
	  </author>

          <date day="8" month="November" year="2014"/>
        </front>
      </reference>

    </references>

  <section title="Additional Token Exchange Examples" anchor="AdditionalExamples">
    <t>
      Two example token exchanges are provided in the following sections
      illustrating impersonation and delegation, respectively
      (with extra line breaks and indentation for display purposes only).
    </t>
  <section title="Impersonation Token Exchange Example" anchor="ImpersonationExample">

    <section anchor="ImpersonationRequest" title="Token Exchange Request">
      <t>
        In the following token exchange request, an anonymous client is requesting a token
        with impersonation semantics.
        The client tells the authorization server that it needs a token for use at
        the target service with the logical name
	<spanx style="verb">urn:example:cooperation-context</spanx>.
      </t>
    <figure title="Token Exchange Request" anchor="ImpersonationRequestEx">
      <artwork><![CDATA[
 POST /as/token.oauth2 HTTP/1.1
 Host: as.example.com
 Content-Type: application/x-www-form-urlencoded

 grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Atoken-exchange
 &audience=urn%3Aexample%3Acooperation-context
 &subject_token=eyJhbGciOiJFUzI1NiIsImtpZCI6IjE2In0.eyJhdWQiOiJodHRwc
   zovL2FzLmV4YW1wbGUuY29tIiwiaXNzIjoiaHR0cHM6Ly9jbGllbnQuZXhhbXBsZS5
   uZXQiLCJleHAiOjE0NDE5MTA2MDAsIm5iZiI6MTQ0MTkwOTAwMCwic3ViIjoiYmNAZ
   XhhbXBsZS5uZXQiLCJzY3AiOlsib3JkZXJzIiwicHJvZmlsZSIsImhpc3RvcnkiXX0
   .F1EZzN9j3LwyrLkDD8pjR7fzHqdYl1ly-jEILfmgKY_0hNuT3_fmUChu9oQdBNjHj
   wu58iLSmagZl-5_9-ilzw
 &subject_token_type=urn%3Aietf%3Aparams%3Aoauth%3Atoken-type%3Ajwt
]]></artwork>
    </figure>
    <!-- JWT signing key for example.net
     {"kty":"EC","kid":"16","use":"sig","alg":"ES256",
     "x":"N_MqlYd_Iq0rfzTqXAX7TUC0r7fQSp3YQKh42tn7uSc",
     "y":"9tGuwMFkHYWPqkLa51f8GazZNQqdgMOVvJEd6fJ18PI",
     "crv":"P-256",
     "d":"cZ_4DqRSAWMMErQbKv6dCYqI9G1pi6lxvlvHU152Uts"}
    -->
    </section>

    <section anchor="ImpersonationSubjectClaims" title="Subject Token Claims">
<t>
  The <spanx style="verb">subject_token</spanx> in the prior request is a JWT and
  the decoded JWT Claims Set is shown here. The JWT is
  intended for consumption by the authorization server within a specific time window.
  The subject of the JWT (<spanx style="verb">bc@example.net</spanx>) is
  the party on behalf of whom the new token is being requested.
</t>
    <figure title="Subject Token Claims" anchor="ImpersonationSubjectClaimsEx">
      <artwork><![CDATA[
  {
    "aud":"https://as.example.com",
    "iss":"https://client.example.net",
    "exp":1441910600,
    "nbf":1441909000,
    "sub":"bc@example.net",
    "scp":["orders","profile","history"]
  }
]]></artwork>
    </figure>
    </section>

    <section anchor="ImpersonationResponse" title="Token Exchange Response">
<t>
  The <spanx style="verb">access_token</spanx> parameter of the token exchange
  response shown below contains the new token that the client requested.
  The other parameters of the response indicate that the token is a JWT
  that expires in an hour and that the access token type is not applicable
  since the issued token is not an access token.
</t>
    <figure title="Token Exchange Response" anchor="ImpersonationResponseEx">
      <artwork><![CDATA[
 HTTP/1.1 200 OK
 Content-Type: application/json
 Cache-Control: no-cache, no-store

 {
  "access_token":"eyJhbGciOiJFUzI1NiIsImtpZCI6IjcyIn0.eyJhdWQiOiJ1cm4
    6ZXhhbXBsZTpjb29wZXJhdGlvbi1jb250ZXh0IiwiaXNzIjoiaHR0cHM6Ly9hcy5l
    eGFtcGxlLmNvbSIsImV4cCI6MTQ0MTkxMzYxMCwic3ViIjoiYmNAZXhhbXBsZS5uZ
    XQiLCJzY3AiOlsib3JkZXJzIiwiaGlzdG9yeSIsInByb2ZpbGUiXX0.YQHuLmI1YD
    TugbfEvgGY2gaGBmMyj9BepZSECCBE9j9ogqZv2qx6VQQPrbT1k7vBYGLNMOkkpmm
    JkxZDS0YV7g",
  "issued_token_type":"urn:ietf:params:oauth:token-type:jwt",
  "token_type":"N_A",
  "expires_in":3600
 }
]]></artwork>
    </figure>
    <!-- JWT signing key for example.com
     {"kty":"EC","kid":"72","use":"sig","alg":"ES256",
     "x":"472aI8TvDdm2qfBRpXYw0uZ7feumuQOM-RPRkkTukSo",
     "y":"VNNStdPhuxY6q7XfVIeYSW7xh_a4z5W2MCtNmQDcILc",
     "crv":"P-256",
     "d":"dtJiut8QBJxACG6fcX8NYnzIsAN1muCJvaMiLSrOjIc"}

    -->
      </section>

    <section anchor="ImpersonationIssuedClaims" title="Issued Token Claims">
<t>
  The decoded JWT Claims Set of the issued token is shown below. The new JWT is
  issued by the authorization server and intended for consumption by a system entity
  known by the logical name <spanx style="verb">urn:example:cooperation-context</spanx>
  any time before its expiration.
  The subject (<spanx style="verb">sub</spanx>) of the JWT
  is the same as the subject the token used to make the request,
  which effectively enables the client to impersonate that subject
  at the system entity known by the logical name of
  <spanx style="verb">urn:example:cooperation-context</spanx> by using the token.
</t>
    <figure anchor="ImpersonationIssuedClaimsEx" title="Issued Token Claims">
      <artwork><![CDATA[
  {
    "aud":"urn:example:cooperation-context",
    "iss":"https://as.example.com",
    "exp":1441913610,
    "sub":"bc@example.net",
    "scp":["orders","history","profile"]
  }
]]></artwork>
    </figure>
      </section>
  </section>

  <section title="Delegation Token Exchange Example" anchor="DelegationExample">

    <section anchor="DelegationRequest" title="Token Exchange Request">
      <t>
        In the following token exchange request, an anonymous client is requesting a token
        with delegation semantics, which is indicated by the inclusion of the
        <spanx style="verb">want_composite</spanx> parameter.
        The client tells the authorization server that it needs a token for use at
        the target service with the logical name
	<spanx style="verb">urn:example:cooperation-context</spanx>.
      </t>
      <figure anchor="DelegationRequestEx" title="Token Exchange Request">
        <artwork><![CDATA[
 POST /as/token.oauth2 HTTP/1.1
 Host: as.example.com
 Content-Type: application/x-www-form-urlencoded

 grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Atoken-exchange
 &audience=urn%3Aexample%3Acooperation-context
 &want_composite=true
 &subject_token=eyJhbGciOiJFUzI1NiIsImtpZCI6IjE2In0.eyJhdWQiOiJodHRwc
   zovL2FzLmV4YW1wbGUuY29tIiwiaXNzIjoiaHR0cHM6Ly9jbGllbnQuZXhhbXBsZS5
   uZXQiLCJleHAiOjE0NDE5MTAwNjAsInNjcCI6WyJzdGF0dXMiLCJmZWVkIl0sInN1Y
   iI6InVzZXJAZXhhbXBsZS5uZXQiLCJtYXlfYWN0Ijp7InN1YiI6ImFkbWluQGV4YW1
   wbGUubmV0In19.cklRpQMYzs9AYoJ3DMht1OnMhAF_0YeQgV35rp7J7ErkvnPm1gr_
   OeQD1wTbnbburbyC7nwKdK5Jrn31aQPxUg
 &subject_token_type=urn%3Aietf%3Aparams%3Aoauth%3Atoken-type%3Ajwt
 &actor_token=eyJhbGciOiJFUzI1NiIsImtpZCI6IjE2In0.eyJhdWQiOiJodHRwczo
   vL2FzLmV4YW1wbGUuY29tIiwiaXNzIjoiaHR0cHM6Ly9jbGllbnQuZXhhbXBsZS5uZ
   XQiLCJleHAiOjE0NDE5MTAwNjAsInN1YiI6ImFkbWluQGV4YW1wbGUubmV0In0.X15
   8zUsO55Fo0humOUCUCy582BQRAWbMsIKbxT1mJRrQrk2cpU6r6CWeI4ukQoQRe6RTr
   Esk4wX2lMf8sELxaA
 &actor_token_type=urn%3Aietf%3Aparams%3Aoauth%3Atoken-type%3Ajwt
]]></artwork>
      </figure>
      <!-- JWT signing key for example.net
       {"kty":"EC","kid":"16","use":"sig","alg":"ES256",
       "x":"N_MqlYd_Iq0rfzTqXAX7TUC0r7fQSp3YQKh42tn7uSc",
       "y":"9tGuwMFkHYWPqkLa51f8GazZNQqdgMOVvJEd6fJ18PI",
       "crv":"P-256",
       "d":"cZ_4DqRSAWMMErQbKv6dCYqI9G1pi6lxvlvHU152Uts"}
      -->
    </section>

    <section anchor="DelegationSubjectClaims" title="Subject Token Claims">
      <t>
        The <spanx style="verb">subject_token</spanx> in the prior request is a JWT and
        the decoded JWT Claims Set is shown here. The JWT is
        intended for consumption by the authorization server
        before a specific expiration time.
	The subject of the JWT
	(<spanx style="verb">user@example.net</spanx>) is
	the party on behalf of whom the new token is being requested.
      </t>
      <figure anchor="DelegationSubjectClaimsEx" title="Subject Token Claims">
        <artwork><![CDATA[
  {
    "aud":"https://as.example.com",
    "iss":"https://client.example.net",
    "exp":1441910060,
    "scp":["status","feed"],
    "sub":"user@example.net",
    "may_act":
    {
      "sub":"admin@example.net"
    }
  }
]]></artwork>
      </figure>
    </section>

    <section anchor="DelegationActorClaims" title="Actor Token Claims">
      <t>
        The <spanx style="verb">actor_token</spanx> in the prior request is a JWT and
        the decoded JWT Claims Set is shown here. This JWT is also
        intended for consumption by the authorization server
        before a specific expiration time.
	The subject of the JWT
	(<spanx style="verb">admin@example.net</spanx>) is
	the actor that will wield the security token being requested.
      </t>
      <figure anchor="DelegationActorClaimsEx" title="Actor Token Claims">
        <artwork><![CDATA[
  {
    "aud":"https://as.example.com",
    "iss":"https://client.example.net",
    "exp":1441910060,
    "sub":"admin@example.net"
  }
]]></artwork>
      </figure>
    </section>

    <section anchor="DelegationResponse" title="Token Exchange Response">
      <t>
        The <spanx style="verb">access_token</spanx> parameter of the token exchange
        response shown below contains the new token that the client requested.
        The other parameters of the response indicate that the token is a JWT
	that expires in an hour and that the access token type is not applicable
	since the issued token is not an access token.
      </t>
      <figure anchor="DelegationResponseEx" title="Token Exchange Response">
        <artwork><![CDATA[
 HTTP/1.1 200 OK
 Content-Type: application/json
 Cache-Control: no-cache, no-store

 {
  "access_token":"eyJhbGciOiJFUzI1NiIsImtpZCI6IjcyIn0.eyJhdWQiOiJ1cm4
    6ZXhhbXBsZTpjb29wZXJhdGlvbi1jb250ZXh0IiwiaXNzIjoiaHR0cHM6Ly9hcy5l
    eGFtcGxlLmNvbSIsImV4cCI6MTQ0MTkxMzYxMCwic2NwIjpbInN0YXR1cyIsImZlZ
    WQiXSwic3ViIjoidXNlckBleGFtcGxlLm5ldCIsImFjdCI6eyJzdWIiOiJhZG1pbk
    BleGFtcGxlLm5ldCJ9fQ._qjM7Ij_HcrC78omT4jiZTFJOuzsAj1wPo31ymQS-Suq
    r64S1jCp6pfQR-in_OOAosAGamEg4jyPsht6kMAiYA",
  "issued_token_type":"urn:ietf:params:oauth:token-type:jwt",
  "token_type":"N_A",
  "expires_in":3600
 }
]]></artwork>
      </figure>
      <!-- JWT signing key for example.com
       {"kty":"EC","kid":"72","use":"sig","alg":"ES256",
       "x":"472aI8TvDdm2qfBRpXYw0uZ7feumuQOM-RPRkkTukSo",
       "y":"VNNStdPhuxY6q7XfVIeYSW7xh_a4z5W2MCtNmQDcILc",
       "crv":"P-256",
       "d":"dtJiut8QBJxACG6fcX8NYnzIsAN1muCJvaMiLSrOjIc"}

      -->
    </section>

    <section anchor="DelegationIssuedClaims" title="Issued Token Claims">
      <t>
        The decoded JWT Claims Set of the issued token is shown below. The new JWT is
        issued by the authorization server and intended for consumption by a system entity
        known by the logical name
	<spanx style="verb">urn:example:cooperation-context</spanx>
	any time before its expiration.
        The subject (<spanx style="verb">sub</spanx>)
  of the JWT
	is the same as the subject of
	the <spanx style="verb">subject_token</spanx> used to make the request.
  The actor (<spanx style="verb">act</spanx>) of the JWT is the same as the subject
	of the <spanx style="verb">actor_token</spanx> used to make the request.

        This indicates delegation and identifies
	<spanx style="verb">admin@example.net</spanx> as the current actor to whom authority
        has been delegated to act on behalf of <spanx style="verb">user@example.net</spanx>.
      </t>
      <figure anchor="DelegationIssuedClaimsEx" title="Issued Token Claims">
        <artwork><![CDATA[
  {
    "aud":"urn:example:cooperation-context",
    "iss":"https://as.example.com",
    "exp":1441913610,
    "scp":["status","feed"],
    "sub":"user@example.net",
    "act":
    {
      "sub":"admin@example.net"
    }
  }
]]></artwork>
      </figure>
    </section>
  </section>

  </section>

    <section anchor="Acknowledgements" title="Acknowledgements">
      <t>
        This specification was developed within the OAuth Working Group, which
        includes dozens of active and dedicated participants.
        It was produced under the chairmanship of
        Hannes Tschofenig and Derek Atkins
        with Kathleen Moriarty and Stephen Farrell serving as
        Security Area Directors.
        The following individuals contributed ideas, feedback, and wording
	to this specification:
      </t>
      <t>
	Caleb Baker,
	William Denniss,
	Phil Hunt,
	Jason Keglovitz,
	Matt Miller,
	Matthew Perry,
	Justin Richer,
	Scott Tomilson,
	and
        Hannes Tschofenig.
      </t>
    </section>

    <section anchor="OpenIssues" title="Open Issues">
      <t>
	The following decisions need to be made and updates to this spec performed:
	<list style="symbols">
	  <t>
      Should there be a way to use short names for some common token type identifiers?
      URIs are necessary in the general case for extensibility and vendor/deployment specific types.
      But short names like <spanx style="verb">access_token</spanx> and <spanx style="verb">jwt</spanx>
      are aesthetically appealing and slightly more efficient in terms of bytes on the wire and url-encoding.
      There seemed to be rough consensus in Prague ('No objection to use the proposed mechanism for a default prefix'
      from https://www.ietf.org/proceedings/93/minutes/minutes-93-oauth) for supporting a shorthand for
      commonly used types - i.e. when the value does not contain a ":" character, the value would
      be treated as though <spanx style="verb">urn:ietf:params:oauth:token-type:</spanx>
      were prepended to it. So, for example, the value <spanx style="verb">jwt</spanx>
      for <spanx style="verb">requested_token_type</spanx> would be semantically equivalent
      to <spanx style="verb">urn:ietf:params:oauth:token-type:jwt</spanx> and the value
      <spanx style="verb">access_token</spanx> would be equivalent to
      <spanx style="verb">urn:ietf:params:oauth:token-type:access_token</spanx>.
      However, it was a fairly brief discussion in Prague and it has since been
      suggested that making participants handle both syntaxes will unnecessarily complicate
      the supporting code.
	  </t>
	  <t>
	    Provide a way to include supplementary claims or information in the request that would/could potentially be included in the
	    issued token. There are real use cases for this but we would need to work through what it would look like.
	  </t>
	  <t>
	    Understand and define exactly how the presentation of PoP/non-bearer tokens works.
	    Of course, the specifications defining these kinds of tokens need to do so
	    first before there is much we can do in this specification in this regard.
	  </t>
	  <t>
	    It seems there may be cases in which it would be desirable for
	    the authenticated client to be somehow represented in the issued token,
	    sometimes in addition to the actor, which can already be represented
	    using the <spanx style="verb">act</spanx> claim.
	    Perhaps with a <spanx style="verb">client_id</spanx> claim?
	  </t>
	</list>
      </t>
    </section>

    <section anchor="History" title="Document History">
      <?rfc subcompact="yes"?>
      <t>
	[[ to be removed by the RFC Editor before publication as an RFC ]]
      </t>
      <t>
        -03
        <list style='symbols'>
          <t>Updated the document editors (adding Campbell, Bradley, and Mortimore).</t>
          <t>Added to the title.</t>
          <t>Added to the abstract and introduction.</t>
          <t>
            Updated the format of the request to use application/x-www-form-urlencoded
	    request parameters and the response to use the existing token endpoint
	    JSON parameters defined in OAuth 2.0.
          </t>
          <t>Changed the grant type identifier to urn:ietf:params:oauth:grant-type:token-exchange.</t>
          <t>
	    Added RFC 6755 registration requests for
	    urn:ietf:params:oauth:token-type:refresh_token,
            urn:ietf:params:oauth:token-type:access_token, and
	    urn:ietf:params:oauth:grant-type:token-exchange.
          </t>
          <t>
            Added RFC 6749 registration requests for request/response parameters.
          </t>
	  <t>
	    Removed the Implementation Considerations and the requirement to support JWTs.
	  </t>
          <t>Clarified many aspects of the text.</t>
          <t>
            Changed <spanx style="verb">on_behalf_of</spanx> to
	    <spanx style="verb">subject_token</spanx>,
	    <spanx style="verb">on_behalf_of_token_type</spanx> to
	    <spanx style="verb">subject_token_type</spanx>,
            <spanx style="verb">act_as</spanx> to
	    <spanx style="verb">actor_token</spanx>, and
	    <spanx style="verb">act_as_token_type</spanx> to
	    <spanx style="verb">actor_token_type</spanx>.
          </t>
          <t>
            Added an <spanx style="verb">audience</spanx> request parameter used to
	    indicate the logical names of the target services at which the client
	    intends to use the requested security token.
          </t>
          <t>
      Added a <spanx style="verb">want_composite</spanx> request parameter used to
      indicate the desire for a composite token rather than trying to infer it from the
      presence/absence of token(s) in the request.
          </t>
          <t>
            Added a <spanx style="verb">resource</spanx> request parameter used to
	    indicate the URLs of resources at which the client
	    intends to use the requested security token.
          </t>
	  <t>
	    Specified that multiple <spanx style="verb">audience</spanx> and
	    <spanx style="verb">resource</spanx> request parameter values may be used.
	  </t>
    <t>
      Defined the JWT claim <spanx style="verb">act</spanx> (actor) to express
	    the current actor or delegation principal.
	  </t>
    <t>
      Defined the JWT claim <spanx style="verb">may_act</spanx> to express
      that one party is authorized to act on behalf of another party.
    </t>
	  <t>
	    Defined the JWT claim <spanx style="verb">scp</spanx> (scopes) to express
	    OAuth 2.0 scope-token values.
          </t>
	  <t>
	    Added the <spanx style="verb">N_A</spanx> (not applicable)
	    OAuth Access Token Type definition for use in contexts in which
	    the token exchange syntax requires a <spanx style="verb">token_type</spanx>
	    value, but in which the token being issued is not an access token.
	  </t>
          <t>Added examples.</t>
        </list>
      </t>
      <t>
        -02
        <list style='symbols'>
	  <t>
	    Enabled use of Security Token types other than JWTs for
	    <spanx style="verb">act_as</spanx> and
	    <spanx style="verb">on_behalf_of</spanx> request values.
	  </t>
          <t>
            Referenced the JWT and OAuth Assertions RFCs.
	  </t>
        </list>
      </t>

      <t>
        -01
        <list style='symbols'>
          <t>
            Updated references.
	  </t>
        </list>
      </t>

      <t>
        -00
        <list style='symbols'>
          <t>
            Created initial working group draft from draft-jones-oauth-token-exchange-01.
	  </t>
        </list>
      </t>
      <?rfc subcompact="no"?>
    </section>     

  </back>
</rfc>
  <!--   code used to create the JWTs in examples


public class TokenExExamplesTest
{
    @Test
    public void go() throws Exception
    {
        main(null);
    }

    public static void main(String[] args) throws Exception
    {
        AlgorithmFactoryFactory.getInstance(); // init to get the logging out of the way
        System.out.println("\nmain-example");
        System.out.println(" main :::::");

        PublicJsonWebKey mainExKey = PublicJsonWebKey.Factory.newPublicJwk("{\"kty\":\"EC\",\"kid\":\"9er\",\"use\":\"sig\",\"alg\":\"ES256\",\"x\":\"5yoR9FjZHn7kJDALhDzhZ8i8F06mc12YswUMTBv4BoA\",\"y\":\"4uxuIItWj5Duzspth5mUbpLXWrPFzFPQkOCeAGGI6KM\",\"crv\":\"P-256\",\"d\":\"LncS7zrx6c8X5qZRxoSN18ZEYDeI2wfKfUvX_DgwRH8\"}");
        System.out.println(mainExKey.toJson(JsonWebKey.OutputControlLevel.INCLUDE_PRIVATE));

        NumericDate iat = NumericDate.fromSeconds(1441917533);
        System.out.println(iat);
        NumericDate exp = NumericDate.fromSeconds(iat.getValue());
        exp.addSeconds(60);

        JwtClaims claims = new JwtClaims();
        claims.setAudience("https://backend.example.com");
        final String asDotComUri = "https://as.example.com";
        claims.setIssuer(asDotComUri);
        claims.setExpirationTime(exp);
        claims.setIssuedAt(iat);
        claims.setStringClaim("azp", "rs08");
        claims.setSubject("bc@example.com");
        claims.setStringListClaim("scp", "api");

        JsonWebSignature jws = new JsonWebSignature();
        jws.setAlgorithmHeaderValue(AlgorithmIdentifiers.ECDSA_USING_P256_CURVE_AND_SHA256);
        jws.setKeyIdHeaderValue(mainExKey.getKeyId());
        jws.setKey(mainExKey.getPrivateKey());
        jws.setPayload(claims.toJson());
        System.out.println(jws.getCompactSerialization());


        System.out.println("\n\n\n\nimpersonation-example");
        System.out.println("\n dot net:::::");
        PublicJsonWebKey dotNetKey = PublicJsonWebKey.Factory.newPublicJwk("{\"kty\":\"EC\",\"kid\":\"16\",\"use\":\"sig\",\"alg\":\"ES256\",\"x\":\"N_MqlYd_Iq0rfzTqXAX7TUC0r7fQSp3YQKh42tn7uSc\",\"y\":\"9tGuwMFkHYWPqkLa51f8GazZNQqdgMOVvJEd6fJ18PI\",\"crv\":\"P-256\",\"d\":\"cZ_4DqRSAWMMErQbKv6dCYqI9G1pi6lxvlvHU152Uts\"}");
        System.out.println(dotNetKey.toJson(JsonWebKey.OutputControlLevel.INCLUDE_PRIVATE));

        iat = NumericDate.fromSeconds(1441910000);
        System.out.println(iat);
        exp = NumericDate.fromSeconds(iat.getValue());
        exp.addSeconds(600);
        NumericDate nbf = NumericDate.fromSeconds(iat.getValue());
        nbf.addSeconds(-1000);

        claims = new JwtClaims();
        claims.setAudience(asDotComUri);
        final String clientNetUri = "https://client.example.net";
        claims.setIssuer(clientNetUri);
        claims.setExpirationTime(exp);
        claims.setNotBefore(nbf);
        claims.setSubject("bc@example.net");
        claims.setStringListClaim("scp", "orders", "profile", "history");

        jws = new JsonWebSignature();
        jws.setAlgorithmHeaderValue(AlgorithmIdentifiers.ECDSA_USING_P256_CURVE_AND_SHA256);
        jws.setKeyIdHeaderValue(dotNetKey.getKeyId());
        jws.setKey(dotNetKey.getPrivateKey());
        String payload = claims.toJson();
        jws.setPayload(payload);
        System.out.println(payload);
        System.out.println("sub token: " + jws.getCompactSerialization());

        System.out.println("\n dot com:::::");
        PublicJsonWebKey dotComKey = PublicJsonWebKey.Factory.newPublicJwk("{\"kty\":\"EC\",\"kid\":\"72\",\"use\":\"sig\",\"alg\":\"ES256\",\"x\":\"472aI8TvDdm2qfBRpXYw0uZ7feumuQOM-RPRkkTukSo\",\"y\":\"VNNStdPhuxY6q7XfVIeYSW7xh_a4z5W2MCtNmQDcILc\",\"crv\":\"P-256\",\"d\":\"dtJiut8QBJxACG6fcX8NYnzIsAN1muCJvaMiLSrOjIc\"}");
        System.out.println(dotComKey.toJson(JsonWebKey.OutputControlLevel.INCLUDE_PRIVATE));

        iat = NumericDate.fromSeconds(1441910010);
        System.out.println(iat);
        exp = NumericDate.fromSeconds(iat.getValue());
        exp.addSeconds(3600);

        claims = new JwtClaims();
        claims.setAudience("urn:example:cooperation-context");
        claims.setIssuer(asDotComUri);
        claims.setExpirationTime(exp);
        claims.setSubject("bc@example.net");
        claims.setStringListClaim("scp", "orders", "history", "profile");

        jws = new JsonWebSignature();
        jws.setAlgorithmHeaderValue(AlgorithmIdentifiers.ECDSA_USING_P256_CURVE_AND_SHA256);
        jws.setKeyIdHeaderValue(dotComKey.getKeyId());
        jws.setKey(dotComKey.getPrivateKey());
        payload = claims.toJson();
        jws.setPayload(payload);
        System.out.println(payload);
        System.out.println("issued token: " + jws.getCompactSerialization());


        System.out.println("\n\n\ndelegation-example");
        System.out.println("\n dot net:::::");


        iat = NumericDate.fromSeconds(1441910000);
        System.out.println(iat);
        exp = NumericDate.fromSeconds(iat.getValue());
        exp.addSeconds(60);

        String admin = "admin@example.net";

        claims = new JwtClaims();
        claims.setAudience(asDotComUri);
        claims.setIssuer(clientNetUri);
        claims.setExpirationTime(exp);
        claims.setStringListClaim("scp", "status", "feed");
        String sub = "user@example.net";
        claims.setSubject(sub);
        JwtClaims mayAct = new JwtClaims();
        mayAct.setSubject(admin);
        claims.setClaim("may_act", mayAct.getClaimsMap());

        jws = new JsonWebSignature();
        jws.setAlgorithmHeaderValue(AlgorithmIdentifiers.ECDSA_USING_P256_CURVE_AND_SHA256);
        jws.setKeyIdHeaderValue(dotNetKey.getKeyId());
        jws.setKey(dotNetKey.getPrivateKey());
        payload = claims.toJson();
        jws.setPayload(payload);
        System.out.println(payload);
        System.out.println("sub token: " + jws.getCompactSerialization());



        claims = new JwtClaims();
        claims.setAudience(asDotComUri);
        claims.setIssuer(clientNetUri);
        claims.setExpirationTime(exp);
        claims.setSubject(admin);

        jws = new JsonWebSignature();
        jws.setAlgorithmHeaderValue(AlgorithmIdentifiers.ECDSA_USING_P256_CURVE_AND_SHA256);
        jws.setKeyIdHeaderValue(dotNetKey.getKeyId());
        jws.setKey(dotNetKey.getPrivateKey());
        payload = claims.toJson();
        jws.setPayload(payload);
        System.out.println(payload);
        System.out.println("del token: " + jws.getCompactSerialization());

        iat = NumericDate.fromSeconds(1441910010);
        System.out.println(iat);
        exp = NumericDate.fromSeconds(iat.getValue());
        exp.addSeconds(3600);

        claims = new JwtClaims();
        claims.setAudience("urn:example:cooperation-context");
        claims.setIssuer(asDotComUri);
        claims.setExpirationTime(exp);
        claims.setStringListClaim("scp", "status", "feed");
        claims.setSubject(sub);
        JwtClaims actor = new JwtClaims();
        actor.setSubject(admin);
        claims.setClaim("act", actor.getClaimsMap());


        jws = new JsonWebSignature();
        jws.setAlgorithmHeaderValue(AlgorithmIdentifiers.ECDSA_USING_P256_CURVE_AND_SHA256);
        jws.setKeyIdHeaderValue(dotComKey.getKeyId());
        jws.setKey(dotComKey.getPrivateKey());
        payload = claims.toJson();
        jws.setPayload(payload);
        System.out.println(payload);
        System.out.println("issued token: " + jws.getCompactSerialization());
    }
}

-->