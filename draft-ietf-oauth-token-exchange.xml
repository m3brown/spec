<?xml version="1.0" encoding="us-ascii"?>
<?xml-stylesheet type='text/xsl' href='http://xml2rfc.tools.ietf.org/authoring/rfc2629.xslt' ?>
<!DOCTYPE rfc SYSTEM "rfc2629.dtd">

<?rfc toc="yes"?>
<?rfc tocompact="yes"?>
<?rfc tocdepth="2"?>
<?rfc tocindent="yes"?>
<?rfc symrefs="yes"?>
<?rfc sortrefs="yes"?>
<?rfc comments="yes"?>
<?rfc inline="yes"?>
<?rfc compact="yes"?>
<?rfc subcompact="no"?>

<rfc category="std" docName="draft-ietf-oauth-token-exchange-03"
     ipr="trust200902">
  <front>
    <title abbrev="Token Exchange">OAuth 2.0 Token Exchange: an STS for the REST of us</title>

    <author fullname="Michael B. Jones" initials="M.B." surname="Jones">
      <organization>Microsoft</organization>
      <address>
        <email>mbj@microsoft.com</email>
        <uri>http://self-issued.info/</uri>
      </address>
    </author>
    <author fullname="Anthony Nadalin" initials="A." surname="Nadalin">
      <organization>Microsoft</organization>
      <address>
        <email>tonynad@microsoft.com</email>
      </address>
    </author>
    <author fullname="Brian Campbell" initials="B." surname="Campbell">
      <organization>Ping Identity</organization>
      <address><email>brian.d.campbell@gmail.com</email></address>
    </author>
    <author fullname="John Bradley" initials="J." surname="Bradley">
      <organization>Ping Identity</organization>
      <address><email>ve7jtb@ve7jtb.com</email></address>
    </author>
    <author fullname="Chuck Mortimore" initials="C." surname="Mortimore">
      <organization abbrev="Salesforce">Salesforce</organization>
      <address>
        <email>cmortimore@salesforce.com</email>
      </address>
    </author>

    <date />

    <area>Security</area>
    <workgroup>OAuth Working Group</workgroup>

    <keyword>RFC</keyword>
    <keyword>Request for Comments</keyword>
    <keyword>I-D</keyword>
    <keyword>Internet-Draft</keyword>
    <keyword>JSON Web Token</keyword>
    <keyword>JWT</keyword>
    <keyword>Delegation</keyword>
    <keyword>Impersonation</keyword>
    <keyword>STS</keyword>
    <keyword>Exchange</keyword>
    <keyword>Token</keyword>
    <keyword>OAuth</keyword>


    <abstract>
      <t>
  This specification provides the framework for a lightweight HTTP and JSON based
  security token service by defining how to request and obtain
  security tokens from OAuth authorization servers,
  including support for impersonation and delegation in the requested token.
      </t>
    </abstract>

  </front>

  <middle>
    <section title="Introduction">
<t>
  A security token is a set of information that facilitates
  the sharing of identity and security information in heterogeneous environments or across security domains.
  Examples of security tokens include
  JSON Web Tokens (JWTs) <xref target="RFC7519"/> and
  SAML Assertions <xref target="OASIS.saml-core-2.0-os"/>.
  Security tokens are typically signed to achieve integrity
  and sometimes also encrypted to achieve confidentiality.
  Security tokens are also described as Assertions in
  <xref target="RFC7521"/>.
</t>

<t>
  A security token service (STS) is a service capable of validating and issuing
  security tokens, which enables web service clients to obtain appropriate temporary
  access credentials for resources in heterogeneous environments or across security
  domains. Clients have historically used <xref target="WS-Trust">WS-Trust</xref>
  as the protocol to interact with an STS for token exchange.
  However WS-Trust is a fairly heavyweight framework which uses XML, SOAP,
  WS-Security, XML-Signatures, etc. while the trend in more modern web development
  has been towards more lightweight services utilizing RESTful patterns and JSON.
  <xref target="RFC6749">The OAuth 2.0 Authorization Framework</xref>
  and <xref target="RFC6750">OAuth 2.0 Bearer Tokens</xref>
  have emerged as popular standards for authorizing and securing access to HTTP and
  RESTful resources but do not provide everything necessary to support generic
  STS interactions.
</t>
<t>
  This specification defines a lightweight protocol extending OAuth 2.0 that enables
  clients to request and obtain security tokens from authorization servers acting in
  the role of an STS.
  Similar to OAuth 2.0, this specification focuses on client developer simplicity and
  requires only an HTTP client and JSON parser, which are nearly universally available
  in modern development environments. The STS protocol defined in this specification
  is not itself RESTful (an STS doesn't lend itself particularly well to a REST
  approach) but does utilize communication patterns and data formats that should be
  more palatable to developers accustom to working with RESTful systems.
</t>
<t>
  A new grant type for a token exchange request and the associated specific parameters for
  such a request to the token endpoint are defined by this specification.
  A token exchange response is a normal OAuth 2.0 response from the token endpoint
  with a few additional parameters defined herein to provide information to the client.
</t>
<t>
  The entity that makes the request to exchange tokens is considered the client in the
  context of the token exchange transaction. However, that does not necessarily restrict
  usage of this profile to traditional OAuth clients. An OAuth resource server, for example,
  might assume the role of the client during token exchange in order to trade an access token
  that it received on an inbound request for a token that is appropriate to include in a
  to call to a backend service. The new token might be a access token that is more
  narrowly scoped for the downstream service or it could be an entirely different type
  of token.
</t>
<t>
  The scope of this specification is limited to the definition of a framework and
  basic request and response protocol for an STS style token exchange utilizing OAuth 2.0.
  Although a few new claims are defined for JWT, which enable delegation semantics to be expressed,
  the specific syntax, semantics and security characteristics of the tokens themselves
  (both those presented to the AS and those obtained by the client)
  are explicitly out of scope and no requirements are placed on the trust model in
  which an implementation might be deployed. Additional profiles may provide
  more detailed requirements around the specific nature of the parties and trust involved,
  whether signatures and/or encryption of tokens is required, etc., however, such details
  will often be policy decisions made with respect to the specific needs of individual
  deployments and will be configured or implemented accordingly.
</t>
<t>
  The security tokens obtained could be used in a number of contexts,
  the specifics of which are also beyond the scope of this document.
</t>

      <section title="Requirements Notation and Conventions">
	<t>
	  The key words "MUST", "MUST NOT", "REQUIRED", "SHALL", "SHALL NOT",
	  "SHOULD", "SHOULD NOT", "RECOMMENDED", "MAY", and "OPTIONAL" in this
	  document are to be interpreted as described in
	  <xref target="RFC2119">RFC 2119</xref>.
	</t>
      </section>

      <section title="Terminology">
        <t>
	  This specification uses the terms "authorization server", "client", "resource server"
	  "token endpoint", "token request", and "token response"
	  defined by <xref target="RFC6749">OAuth 2.0</xref>,
	  and the terms "Claim" and "StringOrURI" defined by
	  <xref target="RFC7519">JSON Web Token (JWT)</xref>.
        </t>
      </section>

      <section title="Delegation vs. Impersonation Semantics">

  <t>
    When principal A impersonates principal B, A is given all
    the rights that B has within some defined rights context
    and is indistinguishable from B in that context.
    Thus, when principal A impersonates principal B, then in
    so far as any entity receiving such a token is concerned, they are
    actually dealing with B. It is true that some members of the
    identity system might have awareness that impersonation is
    going on but it is not a requirement. For all intents and
    purposes, when A is impersonating B, A is B.
  </t>
  <t>
    Delegation semantics are different than
    impersonation semantics, though the two are sometimes confused.
    With delegation semantics, principal A still has its own identity
    separate from B and it is explicitly understood that while B
    may have delegated its rights to A, any actions taken are
    being taken by A and not B. In a sense, A is an agent for B.
  </t>
  <t>
    A security token with impersonation semantics is requested using this framework
    by including a <spanx style="verb">subject_token</spanx> token in the request and omitting the <spanx style="verb">delegate_token</spanx>.
    The <spanx style="verb">subject_token</spanx> represents the identity of the party on behalf of whom
    the token is being requested and the token returned to the client will contain
    information about that party.
  </t>
  <t>
    A security token with delegation semantics is requested using this
    framework by including both a <spanx style="verb">subject_token</spanx> and a <spanx style="verb">delegate_token</spanx> in
    the request. The <spanx style="verb">subject_token</spanx> represents the identity of the party on
    behalf of whom the token is being requested while the <spanx style="verb">delegate_token</spanx> represents
    the identity of the party to whom the access rights of the returned token are
    being delegated. In this case, the token returned to the client will contain
    information about both parties.
  </t>

      </section>

    </section>
    <section title="Token Exchange Request and Response">
    <section title="Request" anchor="Request">
<t>
  A client requests a security token by making a token request to the authorization
  server's token endpoint using the extension grant type mechanism defined
  in <xref target="RFC6749">OAuth 2.0, Section 4.5</xref>.
</t>
<t>
  Client authentication to the authorization server is done using the normal
  mechanisms provided by OAuth 2.0.
  <xref target="RFC6749">The OAuth 2.0 Authorization Framework, Section 2.3.1</xref>
  defines password-based authentication of the client,
  however, client authentication is extensible and other mechanisms are possible.
  For example, <xref target="RFC7523"/> defines client authentication using
  JSON Web Tokens (JWTs) <xref target="RFC7519"/>.
  Other mechanisms, such as TLS client authentication, are also possible.
  The supported methods of client authentication and whether or not to allow
  unauthenticated or unidentified clients are deployment decisions that are
  at the discretion of the authorization server.
</t>
<t>
  The client makes a general token exchange request to the token endpoint with an extension
  grant type by including the
  following parameters using the <spanx style='verb'>application/x-www-form-urlencoded</spanx>
  format with a character encoding of UTF-8 in the HTTP request entity-body:
</t>
<t>
<list style="hanging">

  <t hangText="grant_type">
    <vspace/>
    REQUIRED. The value
    <spanx style='verb'>urn:ietf:params:oauth:grant-type:token-exchange</spanx>
    indicates that it is a token exchange request.
  </t>

  <t hangText="resource">
    <vspace/>
    OPTIONAL.
    Indicates the physical location of the target service or resource where the client intends to use
    the requested security token. This enables the authorization server to apply policy as appropriate
    for the target, such as determining the type and content of the token to be returned or if and how
    the token is to be encrypted.
    In many cases a client will not have knowledge of the logical organization of the systems with
    which it interacts and will only know the location of the service where it intends to use the token.
    The <spanx style="verb">resource</spanx> parameter allows the client to indicate to the authorization server
    where it intends to use the requested token by providing the location, typically as an https URL, in the
    token exchange request in the same form that will be used to access that resource.
    The authorization server will typically have the capability to map from a resource URI value to
    a an appropriate policy. The value of the <spanx style="verb">resource</spanx> parameter MUST be an
    absolute URI as defined by Section 4.3 of <xref target="RFC3986"/>, which MAY include a query component.
  </t>

  <t hangText="audience">
    <vspace/>
    OPTIONAL.
    The logical name of the target service where the client intends to use
    the requested security token. This serves a purpose similar to the
    <spanx style="verb">resource</spanx> parameter but with the client providing a logical name
    rather than a physical location. Interpretation of the name requires that the value be something
    that both the client and the authorization server understand. An OAuth client identifier,
    a SAML entity identifier, or an OpenID Connect Issuer Identifier are examples of things that
    might be used as <spanx style="verb">audience</spanx> parameter values.
  </t>

  <t hangText="scope">
    <vspace/>
    OPTIONAL.
    A list of space-delimited, case-sensitive strings that allow the client to
    specify the desired scope of requested security token in the context of the
    service or resource where the token will be used.</t>

  <t hangText="requested_token_type">
    <vspace/>
    OPTIONAL.
    An identifier, as described in <xref target="TokenTypeIdentifiers"/>, for the type of the requested security token.
    For example, a JWT can be requested with the identifier
    <spanx style="verb">urn:ietf:params:oauth:token-type:jwt</spanx>.
    If the requested type is unspecified, the returned token type is at
    the discretion of the authorization server and may be dictated by
    knowledge of the requirements of the service or resource
    indicated by the <spanx style='verb'>resource</spanx> or
    <spanx style="verb">audience</spanx> parameter.
  </t>

  <t hangText="subject_token">
    <vspace/>
    REQUIRED.
    The value of this request parameter is a security token which represents the
    identity of the party on behalf of whom the request is being made.
    Typically the subject of this token will be the primary subject of
    the security token returned in response to this request.
  </t>

  <t hangText="subject_token_type">
    <vspace/>
    REQUIRED.
    An identifier, as described in <xref target="TokenTypeIdentifiers"/>, that indicates the type of the security token sent with
    the <spanx style="verb">subject_token</spanx> parameter. For example,
    a value of <spanx style="verb">urn:ietf:params:oauth:token-type:jwt</spanx>,
    would indicate that the token is a JWT and a value of
    <spanx style="verb">urn:ietf:params:oauth:token-type:access_token</spanx>
    would indicate that the token is an OAuth access token.
  </t>

  <t hangText="delegate_token">
    <vspace/>
    OPTIONAL.
    The value of this request parameter is a security token which represents
    the identity of the party that is authorized to use the requested security token.
    When this parameter is present, it indicates that the client wants a token
    that contains claims about two distinct entities:
    1) the entity represented by the token in the <spanx style="verb">subject_token</spanx>
    parameter as the primary subject and 2) the entity represented by this token as a
    party who is authorized to act on behalf of that subject.
  </t>

  <t hangText="delegate_token_type">
    <vspace/>
    REQUIRED when the <spanx style="verb">delegate_token</spanx> parameter is present in the
    request but MUST NOT be included otherwise. The value of this parameter is
    an identifier, as described in <xref target="TokenTypeIdentifiers"/>, that indicates the type of the security token sent with the
    <spanx style="verb">delegate_token</spanx> parameter.
  </t>
</list>
</t>

    </section>

    <section title="Response" anchor="Response">
<t>
  The authorization server responds to a token exchange request with a normal
  OAuth 2.0 response from the token endpoint as defined in
  <xref target="RFC6749">Section 5 of RFC 6749</xref>. Additional details and
  explanation are provided in the following subsections.
</t>
      <section title="Successful Response" anchor="SuccessfulResponse">
<t>
  If the request is valid and meets all policy and other criteria of the authorization server,
  a successful token response is constructed by adding the following parameters
  to the entity-body of the HTTP response using the "application/json"
  media type as defined by <xref target="RFC7159"/> and an HTTP 200 status code.  The
  parameters are serialized into a JavaScript Object Notation (JSON)
  structure by adding each parameter at the top level.
  Parameter names and string values are included as JSON strings.
  Numerical values are included as JSON numbers.  The order of
  parameters does not matter and can vary.
</t>
        <t>
          <list style="hanging">

<t hangText="access_token">
  <vspace/>
  REQUIRED. The security token issued by the authorization server in response
  to the token exchange request.
  The <spanx style="verb">access_token</spanx> parameter from
  <xref target="RFC6749">Section 5.1 of RFC 6749</xref> is used here to carry the requested
  token, which allows this token exchange framework to use the existing OAuth 2.0 request
  and response constructs defined for the token endpoint. The name is used for historical
  reasons and the returned token need not necessarily be an OAuth access token.
</t>

<t hangText="requested_token_type">
  <vspace/>
  REQUIRED.  An identifier, as described in <xref target="TokenTypeIdentifiers"/>,
  for the general type of the returned security token.
  For example, if the security token is a JWT, this value of the
  <spanx style="verb">requested_token_type</spanx> is
  <spanx style="verb">urn:ietf:params:oauth:token-type:jwt</spanx>.
</t>

<t hangText="token_type">
  <vspace/>
  REQUIRED.  A case insensitive value describing the type of the token issued as discussed in
  <xref target="RFC6749">Section 7.1 of RFC 6749</xref>. Note that this value is different from
  the value of the <spanx style="verb">requested_token_type</spanx> and provides the client
  with information about how to utilize the token to access protected resources. For example,
  a value of <spanx style="verb">Bearer</spanx> as defined in <xref target="RFC6750"/> indicates that
  the security token is a bearer token and the client can simply present it as is without any
  additional proof of eligibility beyond the contents of the token itself.
  A value of <spanx style="verb">PoP</spanx>, on the other hand, indicates that use of
  the token will require demonstrating possession of a cryptographic key associated with the
  security token (<xref target="I-D.ietf-oauth-pop-key-distribution"/> describes the
  <spanx style="verb">PoP</spanx> token type).
</t>

<t hangText="expires_in">
  <vspace/>
  RECOMMENDED.  The validity lifetime, in seconds, of the security token issued by the
  authorization server. Oftentimes the client will not have the inclination or capability
  to inspect the content of the token and this parameter provides a consistent and token type
  agnostic indication of long the token can be expected to be valid.
  For example, the value 1800 denotes that the token will
  expire in thirty minutes from the time the response was generated.
</t>

<t hangText="scope">
  <vspace/>
  OPTIONAL, if the scope of the security token is identical to the scope requested by the client;
  otherwise, REQUIRED.
</t>

<t hangText="refresh_token">
  <vspace/>
  NOT RECOMMENDED.
  Refresh tokens will typically not be issued in response to a
  <spanx style="verb">urn:ietf:params:oauth:grant-type:token-exchange</spanx>
  grant type requests.
</t>

        </list>
        </t>
      </section>
      <section title="Error Response">
  <t>
    If either the <spanx style="verb">subject_token</spanx> or <spanx style="verb">delegate_token</spanx>
    are invalid for any reason, or are unacceptable based on policy, the authorization server
    MUST construct an error response as defined in <xref target="RFC6749">Section 5.2 of OAuth 2.0</xref>
    The value of the <spanx style='verb'>error</spanx>
    parameter MUST be the <spanx style='verb'>invalid_grant</spanx> error code. The authorization
    server MAY include additional information regarding the reasons for the error
    using the <spanx style='verb'>error_description</spanx> or <spanx style='verb'>error_uri</spanx> parameters.
  </t>
      </section>


    </section>

<section title="Example Token Exchange" anchor="main-example">
<t>
  The following example demonstrates a hypothetical token exchange where an
  OAuth resource server
  assumes the role of the client during token exchange in order to
  trade an access token that it received on an inbound request for a
  token that it will use to call to a backend service
  (extra line breaks and indentation in the examples are for display purposes only).
</t>


<t>
  The resource server receives the following inbound request containing a
  OAuth access token in the Authorization request header (per
  <xref target="RFC6750">Section 2.1 of RFC 6750</xref>).
</t>

<figure>
  <artwork><![CDATA[
 GET /resource HTTP/1.1
 Host: frontend.example.com
 Authorization: Bearer accVkjcJyb4LBxGsndESCJQbdFMogUC5PbRDqceLTC
]]></artwork>
</figure>

<t>
  The resource server assumes the role of the client for the token exchange
  and the access token from the inbound request above is sent
  to the authorization
  server using a request as defined in <xref target="Request"/>.
  The value of the <spanx style="verb">subject_token</spanx> parameter carries the
  access token and,
  using the shorthand described in <xref target="TokenTypeIdentifiers"/>, the value of
  the <spanx style="verb">subject_token_type</spanx> parameter indicates that it is a
  OAuth 2.0 access token.
  The client uses its identifier and secret to authenticate to
  the authorization server using the HTTP Basic authentication scheme.
  The <spanx style="verb">resource</spanx> parameter indicates the location
  of the backend service, https://backend.example.com/api,
  where the requested token will be used.
</t>

<figure>
  <artwork><![CDATA[
 POST /as/token.oauth2 HTTP/1.1
 Host: as.example.com
 Authorization: Basic cnMwODpsb25nLXNlY3VyZS1yYW5kb20tc2VjcmV0
 Content-Type: application/x-www-form-urlencoded

 grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Atoken-exchange
 &resource=https%3A%2F%2Fbackend.example.com%2Fapi%20
 &subject_token=accVkjcJyb4LBxGsndESCJQbdFMogUC5PbRDqceLTC
 &subject_token_type=access_token
]]></artwork>
</figure>

<t>
  The authorization server validates the client credentials and the
  <spanx style="verb">subject_token</spanx> presented in the token
  exchange request. From the <spanx style="verb">resource</spanx>
  parameter, the authorization server is able to determine the
  appropriate policy to apply to the request and issue a token
  suitable for https://backend.example.com.
  The <spanx style="verb">access_token</spanx> parameter of the
  response contains the new token, which is itself a bearer OAuth
  access token that is valid for one minute. The token happens to be
  a JWT, however, its structure and format are opaque to
  the client so the <spanx style="verb">requested_token_type</spanx>
  indicates only that it is an access token.
</t>

  <figure>
    <artwork><![CDATA[
 HTTP/1.1 200 OK
 Content-Type: application/json
 Cache-Control: no-cache, no-store

 {
  "access_token":"eyJhbGciOiJFUzI1NiIsImtpZCI6IjllciJ9.eyJhdWQiOiJi
      YWNrZW5kLmV4YW1wbGUuY29tIiwiaXNzIjoiYXMuZXhhbXBsZS5jb20iLCJle
      HAiOjE0NDE5MTc1OTMsImlhdCI6MTQ0MTkxNzUzMywiYXpwIjoicnMwOCIsIn
      N1YiI6ImJjYW1wYmVsbEBleGFtcGxlLmNvbSIsImN0eCI6WyJhcGkiXX0.YQ9
      7nJpB37bcwnOCJFRckGUzl_eIGl_setidJPLv4u-DHZq8NV6KNTpggr1zPe66
      cplnQQ_FRxP7i2tnK0Hlug",
  "token_type":"Bearer",
  "requested_token_type":"access_token"
  "expires_in":60,
 }
]]></artwork>
  </figure>

<t>
  The resource server can then use the newly acquired access token in making
  a request to the backend server.
</t>

      <figure>
        <artwork><![CDATA[
 GET /api HTTP/1.1
 Host: backend.example.com
 Authorization: Bearer eyJhbGciOiJFUzI1NiIsImtpZCI6IjllciJ9.eyJhdWQ
     iOiJiYWNrZW5kLmV4YW1wbGUuY29tIiwiaXNzIjoiYXMuZXhhbXBsZS5jb20iL
     CJleHAiOjE0NDE5MTc1OTMsImlhdCI6MTQ0MTkxNzUzMywiYXpwIjoicnMwOCI
     sInN1YiI6ImJjYW1wYmVsbEBleGFtcGxlLmNvbSIsImN0eCI6WyJhcGkiXX0.Y
     Q97nJpB37bcwnOCJFRckGUzl_eIGl_setidJPLv4u-DHZq8NV6KNTpggr1zPe6
     6cplnQQ_FRxP7i2tnK0Hlug
]]></artwork>
      </figure>

  <!--    JWT signing key
  {"kty":"EC","kid":"9er","use":"sig","alg":"ES256",
  "x":"5yoR9FjZHn7kJDALhDzhZ8i8F06mc12YswUMTBv4BoA",
  "y":"4uxuIItWj5Duzspth5mUbpLXWrPFzFPQkOCeAGGI6KM",
  "crv":"P-256",
  "d":"LncS7zrx6c8X5qZRxoSN18ZEYDeI2wfKfUvX_DgwRH8"}
  -->
</section>
    </section>
    <section anchor="TokenTypeIdentifiers" title="Token Type Identifiers">
<t>
  Several parameters in this specification utilize an identifier as the value to
  describe the type of token in question. Specifically they are the
  <spanx style="verb">requested_token_type</spanx>,
  <spanx style="verb">subject_token_type</spanx>, <spanx style="verb">delegate_token_type</spanx>
  parameters of the request and the <spanx style="verb">requested_token_type</spanx> member of the response.
</t>
<t>
  The values of token type identifiers are expressed as URIs with a shorthand allowed for
  commonly used types. When the value does not contain a ":" character, the value MUST
  be evaluated as though <spanx style="verb">urn:ietf:params:oauth:token-type:</spanx>
  were prepended to it. For example, the value <spanx style="verb">jwt</spanx>
  for <spanx style="verb">requested_token_type</spanx> is semantically equivalent
  to <spanx style="verb">urn:ietf:params:oauth:token-type:jwt</spanx> and the value
  <spanx style="verb">access_token</spanx> is equivalent to
  <spanx style="verb">urn:ietf:params:oauth:token-type:access_token</spanx>.
</t>
<t>
  This specification defines
  <spanx style="verb">urn:ietf:params:oauth:token-type:access_token</spanx> and
  <spanx style="verb">urn:ietf:params:oauth:token-type:refresh_token</spanx> to indicate
  an OAuth 2.0 access token and refresh token respectively.
  The value <spanx style="verb">urn:ietf:params:oauth:token-type:jwt</spanx> is defined in
  <xref target="RFC7519">Section 9 of RFC 7519</xref> and is used to indicate that a
  token is a JWT.
</t>
   </section>

    <section title="JSON Web Token Claims" anchor="jwtclaims">
 <t>
   It is useful to have defined mechanisms to express delegation within a token as well as to express
   authorization to delegate or impersonate. Although the token exchange protocol described
   herein can be used with any type of token, this section defines claims to express such
   semantics specifically for JWT. Similar definitions for other types of tokens are possible but
   beyond the scope of this document.
 </t>
  <section title="Actor 'act' Claim" anchor="actor">
    <t>
      The <spanx style="verb">act</spanx> (actor) claim provides a means within a JWT
      to express that delegation has occurred.
      The <spanx style="verb">act</spanx> claim value is a case-sensitive string
      containing a StringOrURI value, which identifies the principal that
      is the current actor to whom authority has been delegated.
    </t>
  </section>
  <section title="Context 'ctx' Claim" anchor="ctx">
    <t>
      The <spanx style="verb">ctx</spanx> (context) claim is an array of strings,
      each of which represents a service context
      that the presenter of the token is eligible to execute.
      The array MUST contain at least one context value.
      The definition of these contexts is outside the scope of this specification.
      However, as one example, the <spanx style="verb">ctx</spanx> claim might be used to carry
      an OAuth scope value where each array entry of the
      claim value is a scope-token (scope and scope-token are defined in
      <xref target="RFC6749">OAuth 2.0, Section 3.3</xref>).
    </t>
  </section>
  <section title="On-Behalf-Of 'obo' Claim" anchor="obo">
    <t>
      This claim makes a statement that one party is authorized to act on behalf of another party.
      The value of the claim is a case-sensitive string containing a StringOrURI value, which
      identifies the party whom the presenter of the token is authorized to act for.
    </t>
  </section>

    </section>

    <section title="IANA Considerations">
      <t>
        This specification requests that IANA register the following
        values in the IANA urn:ietf:params:oauth registry established in
        <xref target="RFC6755">An IETF URN Sub-Namespace for OAuth</xref>.

        <?rfc subcompact="yes"?>
        <list style="symbols">
          <t>URN: urn:ietf:params:oauth:grant-type:token-exchange</t>
          <t>Common Name: Token exchange grant type for OAuth 2.0</t>
          <t>Change controller: IESG</t>
          <t>Specification Document: <xref target="Request"/> of [[ this document ]]</t>
        </list>
      </t>
      <t>
        <list style="symbols">
          <t>URN: urn:ietf:params:oauth:token-type:access_token</t>
          <t>Common Name: Token type URI for an OAuth 2.0 access token</t>
          <t>Change controller: IESG</t>
          <t>Specification Document: <xref target="TokenTypeIdentifiers"/> of [[this document]]</t>
        </list>
      </t>
      <t>
        <list style="symbols">
          <t>URN: urn:ietf:params:oauth:token-type:refresh_token</t>
          <t>Common Name:Token Type URI for an OAuth 2.0 refresh token</t>
          <t>Change controller: IESG</t>
          <t>Specification Document: <xref target="TokenTypeIdentifiers"/> of [[this document]]</t>
        </list>

      </t>
      <?rfc subcompact="no"?>

      <t>
        Additionally, this specification requests that IANA register the following
        values in the "OAuth Parameters" registry established by RFC 6749 <xref target="RFC6749"/>.
        <?rfc subcompact="yes"?>
        <list style='symbols'>
          <t>Parameter name: resource</t>
          <t>Parameter usage location: token request</t>
          <t>Change controller: IESG</t>
          <t>Specification document(s): <xref target="Request"/> of [[ this document ]]</t>
        </list>
      </t>
      <t>
        <list style='symbols'>
          <t>Parameter name: audience</t>
          <t>Parameter usage location: token request</t>
          <t>Change controller: IESG</t>
          <t>Specification document(s): <xref target="Request"/> of [[ this document ]]</t>
        </list>
      </t>
      <t>
        <list style='symbols'>
          <t>Parameter name: requested_token_type</t>
          <t>Parameter usage location: token request</t>
          <t>Change controller: IESG</t>
          <t>Specification document(s): <xref target="Request"/> of [[ this document ]]</t>
        </list>
      </t>
      <t>
        <list style='symbols'>
          <t>Parameter name: subject_token</t>
          <t>Parameter usage location: token request</t>
          <t>Change controller: IESG</t>
          <t>Specification document(s): <xref target="Request"/> of [[ this document ]]</t>
        </list>
      </t>
      <t>
        <list style='symbols'>
          <t>Parameter name: subject_token_type</t>
          <t>Parameter usage location: token request</t>
          <t>Change controller: IESG</t>
          <t>Specification document(s): <xref target="Request"/> of [[ this document ]]</t>
        </list>
      </t>
      <t>
        <list style='symbols'>
          <t>Parameter name: delegate_token</t>
          <t>Parameter usage location: token request</t>
          <t>Change controller: IESG</t>
          <t>Specification document(s): <xref target="Request"/> of [[ this document ]]</t>
        </list>
      </t>
      <t>
        <list style='symbols'>
          <t>Parameter name: delegate_token_type</t>
          <t>Parameter usage location: token request</t>
          <t>Change controller: IESG</t>
          <t>Specification document(s): <xref target="Request"/> of [[ this document ]]</t>
        </list>
      </t>
      <t>
        <list style='symbols'>
          <t>Parameter name: requested_token_type</t>
          <t>Parameter usage location: token response</t>
          <t>Change controller: IESG</t>
          <t>Specification document(s): <xref target="SuccessfulResponse"/> of [[ this document ]]</t>
        </list>
      </t>
      <?rfc subcompact="no"?>
      <t>
        Lastly, this specification requests that IANA register the following Claims
        in the IANA JSON Web Token Claims registry established by <xref target="RFC7519">JWT</xref>.
        <?rfc subcompact="yes"?>
        <list style='symbols'>
          <t>Claim Name: <spanx style="verb">act</spanx></t>
          <t>Claim Description: Actor</t>
          <t>Change Controller: IESG</t>
          <t>Specification Document(s): <xref target="actor"/> of [[ this document ]]</t>
        </list>
      </t>
      <t>
        <list style='symbols'>
          <t>Claim Name: <spanx style="verb">ctx</spanx></t>
          <t>Claim Description: Context</t>
          <t>Change Controller: IESG</t>
          <t>Specification Document(s): <xref target="ctx"/> of [[ this document ]]</t>
        </list>
      </t>
      <t>
        <list style='symbols'>
          <t>Claim Name: <spanx style="verb">obo</spanx></t>
          <t>Claim Description: On-Behalf-Of</t>
          <t>Change Controller: IESG</t>
          <t>Specification Document(s): <xref target="obo"/> of [[ this document ]]</t>
        </list>
      </t>
      <?rfc subcompact="no"?>
    </section>

    <section title="Security Considerations">
      <t>
        All of the normal security issues, especially in relationship
        to comparing URIs and dealing with unrecognized values, that
        are discussed in <xref target="RFC7519">JWT</xref> also apply
        here.
      </t>
      <t>
        In addition, both delegation and impersonation introduce unique security
        issues.  Any time one principal is delegated the rights of
        another principal, the potential for abuse is always a concern.
	The use of the <spanx style="verb">ctx</spanx>
	claim is suggested to mitigate potential for such abuse as it restricts the contexts in which
	the delegated rights can be exercised.
      </t>
    </section>
  </middle>

  <back>
    <references title="Normative References">
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml' ?>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6749.xml' ?>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7519.xml' ?>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml' ?>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7159.xml' ?>
    </references>

    <references title="Informative References">
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6755.xml' ?>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6750.xml' ?>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7521.xml' ?>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7523.xml' ?>
      <?rfc include="reference.I-D.ietf-oauth-pop-key-distribution"?>
      <?rfc include='http://xml2rfc.tools.ietf.org/public/rfc/bibxml2/reference.OASIS.saml-core-2.0-os.xml' ?>
      <reference anchor="WS-Trust" target="http://docs.oasis-open.org/ws-sx/ws-trust/v1.4/ws-trust.html">
        <front>
          <title>WS-Trust 1.4</title>
          <author fullname="Anthony Nadalin" initials="A." surname="Nadalin"/>
          <author fullname="Marc Goodner" initials="M." surname="Goodner"/>
          <author fullname="Martin Gudgin" initials="M." surname="Gudgin"/>
          <author fullname="Abbie Barbir" initials="A." surname="Barbir"/>
          <author fullname="Hans Granqvist" initials="H." surname="Granqvist"/>
          <date day="2" month="February" year="2012"/>
        </front>
      </reference>

    </references>

   <section title="Open Issues">
      <t>
	The following decisions need to be made and updates on this spec performed:
	<list style="symbols">
	  <t>
      Understand and define exactly how the presentation of PoP/non-bearer tokens works.
	  </t>
	</list>
      </t>
    </section>

  <section title="Additional Token Exchange Examples" anchor="more-examples">
    <t>
      Two example token exchanges are provided in the following sections illustrating impersonation and
      delegation, respectively
      (extra line breaks and indentation in all the examples are for display purposes only).
    </t>
  <section title="Impersonation Token Exchange Example" anchor="impersonation-example">

    <section title="Token Exchange Request">
      <t>
        In the following token exchange request, an anonymous client is requesting a token with
        with impersonation semantics, which is indicated by the inclusion of the
        <spanx style="verb">subject_token</spanx> parameter and omission of
        the <spanx style="verb">delegate_token</spanx> parameter.
        The client tells the authorization server that it needs a token for use at
        the target service with the logical name "example.org".
      </t>
    <figure>
      <artwork><![CDATA[
 POST /as/token.oauth2 HTTP/1.1
 Host: as.example.com
 Content-Type: application/x-www-form-urlencoded

 grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Atoken-exchange
 &audience=example.org
 &subject_token=eyJhbGciOiJFUzI1NiIsImtpZCI6IjE2In0.eyJhdWQiOiJleGFtc
   GxlLmNvbSIsImlzcyI6ImV4YW1wbGUubmV0IiwiZXhwIjoxNDQxOTEwNjAwLCJuYmY
   iOjE0NDE5MDkwMDAsInN1YiI6ImJjQGV4YW1wbGUubmV0IiwiY3R4IjpbIm9yZGVyc
   yIsInByb2ZpbGUiLCJoaXN0b3J5Il19.JqU2r2NBwqvtg_euvBGmR4Lni7U3i_7G0R
   9liheGneKl20yGp5dU0N5Ain2K0GMopigQXSs0GrlLycCx015vpg
 &subject_token_type=jwt
]]></artwork>
    </figure>
    <!-- JWT signing key for example.net
     {"kty":"EC","kid":"16","use":"sig","alg":"ES256",
     "x":"N_MqlYd_Iq0rfzTqXAX7TUC0r7fQSp3YQKh42tn7uSc",
     "y":"9tGuwMFkHYWPqkLa51f8GazZNQqdgMOVvJEd6fJ18PI",
     "crv":"P-256",
     "d":"cZ_4DqRSAWMMErQbKv6dCYqI9G1pi6lxvlvHU152Uts"}
    -->
    </section>

    <section title="Subject Token Claims">
<t>
  The <spanx style="verb">subject_token</spanx> in the prior request is a JWT and
  the decoded claim set is shown here. The JWT is
  intended for consumption by the authorization server
  within a specific time window. The subject (<spanx style="verb">sub</spanx>) of
  the JWT is the party on behalf of whom the new token is being requested.
</t>
    <figure>
      <artwork><![CDATA[
 {
  "aud":"example.com",
  "iss":"example.net",
  "exp":1441910600,
  "nbf":1441909000,
  "sub":"bc@example.net",
  "ctx":["orders","profile","history"]
 }
]]></artwork>
    </figure>
    </section>

    <section title="Token Exchange Response">
<t>
  The <spanx style="verb">access_token</spanx> parameter of the token exchange
  response shown below contains the new token that the client requested.
  The other parameters of the response
  indicates that the token is a JWT that expires in an hour.
</t>
    <figure>
      <artwork><![CDATA[
 HTTP/1.1 200 OK
 Content-Type: application/json
 Cache-Control: no-cache, no-store

 {
  "access_token":"eyJhbGciOiJFUzI1NiIsImtpZCI6IjcyIn0.eyJhdWQiOiJle
      GFtcGxlLm9yZyIsImlzcyI6ImV4YW1wbGUuY29tIiwiZXhwIjoxNDQxOTEzNj
      EwLCJzdWIiOiJiY0BleGFtcGxlLm5ldCIsImN0eCI6WyJvcmRlcnMiLCJoaXN
      0b3J5IiwicHJvZmlsZSJdfQ.A_EiUwvzIh-SGgzrl5dqX26QXNMi94ZEzP-dw
      -ZqRk3LriPdNqcMpqhopM5oKkDQRZexQaYZBdDZLvgrnP6piA",
  "token_type":"Bearer",
  "requested_token_type":"jwt"
  "expires_in":3600,
 }
]]></artwork>
    </figure>
    <!-- JWT signing key for example.com
     {"kty":"EC","kid":"72","use":"sig","alg":"ES256",
     "x":"472aI8TvDdm2qfBRpXYw0uZ7feumuQOM-RPRkkTukSo",
     "y":"VNNStdPhuxY6q7XfVIeYSW7xh_a4z5W2MCtNmQDcILc",
     "crv":"P-256",
     "d":"dtJiut8QBJxACG6fcX8NYnzIsAN1muCJvaMiLSrOjIc"}

    -->
      </section>

    <section title="Requested Token Claims">
<t>
  The decoded claim set of the requested token is shown below. The new JWT is
  issued by the authorization server and intended for consumption by a system entity
  known by the logical name "example.org" anytime before the its expiration.
  The subject (<spanx style="verb">sub</spanx>) of
  the JWT is the same as the subject of the token used to make the request,
  which effectively enables the client to impersonate the subject by
  using the token at the system entity known as "example.org".
</t>
    <figure>
      <artwork><![CDATA[
 {
  "aud":"example.org",
  "iss":"example.com",
  "exp":1441913610,
  "sub":"bc@example.net",
  "ctx":["orders","history","profile"]
 }
]]></artwork>
    </figure>
      </section>
  </section>

  <section title="Delegation Token Exchange Example" anchor="delegation-example">


    <section title="Token Exchange Request">
      <t>
        In the following token exchange request, an anonymous client is requesting a token with
        with delegation semantics, which is indicated by the inclusion of both the
        <spanx style="verb">subject_token</spanx> parameter and
        the <spanx style="verb">delegate_token</spanx> parameter.
        The client tells the authorization server that it needs a token for use at
        the target service with the logical name "example.org".
      </t>
      <figure>
        <artwork><![CDATA[
 POST /as/token.oauth2 HTTP/1.1
 Host: as.example.com
 Content-Type: application/x-www-form-urlencoded

 grant_type=urn%3Aietf%3Aparams%3Aoauth%3Agrant-type%3Atoken-exchange
 &audience=example.org
 &subject_token=eyJhbGciOiJFUzI1NiIsImtpZCI6IjE2In0.eyJhdWQiOiJleGFtc
   GxlLmNvbSIsImlzcyI6ImV4YW1wbGUubmV0IiwiZXhwIjoxNDQxOTEwMDYwLCJzdWI
   iOiJhY2NAZXhhbXBsZS5uZXQifQ.LWlZ2dc96bLt5LZ9xgkxyjUaiC-akdL_wFgwRQ
   JblY7FrYA2pmZj3oViNyyWVBcA9yd_vP5se1PtBJtrrYOP1w
 &subject_token_type=jwt
 &delegate_token=eyJhbGciOiJFUzI1NiIsImtpZCI6IjE2In0.eyJhdWQiOiJleGFt
   cGxlLmNvbSIsImlzcyI6ImV4YW1wbGUubmV0IiwiZXhwIjoxNDQxOTEwMDYwLCJjdH
   giOlsic3RhdHVzIiwiZmVlZCJdLCJvYm8iOiJhY2NAZXhhbXBsZS5uZXQiLCJzdWIi
   OiJsdGNAZXhhbXBsZS5uZXQifQ.4TimxtHq8xEXXWssUPe-UB8ONTmdyZ8bNQiT8H7
   Fmmtvk7nD3JGNAkjEuV7rMFrrz6HOOhbryr5WoIdAExYG4A
 &delegate_token_type=jwt
]]></artwork>
      </figure>
      <!-- JWT signing key for example.net
       {"kty":"EC","kid":"16","use":"sig","alg":"ES256",
       "x":"N_MqlYd_Iq0rfzTqXAX7TUC0r7fQSp3YQKh42tn7uSc",
       "y":"9tGuwMFkHYWPqkLa51f8GazZNQqdgMOVvJEd6fJ18PI",
       "crv":"P-256",
       "d":"cZ_4DqRSAWMMErQbKv6dCYqI9G1pi6lxvlvHU152Uts"}
      -->
    </section>

    <section title="Subject Token Claims">
      <t>
        The <spanx style="verb">subject_token</spanx> in the prior request is a JWT and
        the decoded claim set is shown here. The JWT is
        intended for consumption by the authorization server
        before a specific expiration time. The subject (<spanx style="verb">sub</spanx>) of
        the JWT ("acc@example.net") is the party on behalf of whom the new token is being requested.
      </t>
      <figure>
        <artwork><![CDATA[
 {
  "aud":"example.com",
  "iss":"example.net",
  "exp":1441910060,
  "sub":"acc@example.net"
 }
]]></artwork>
      </figure>
    </section>

    <section title="Delegate Token Claims">
      <t>
        The <spanx style="verb">delegate_token</spanx> in the prior request is a JWT and
        the decoded claim set is shown here. This JWT is also
        intended for consumption by the authorization server
        before a specific expiration time. The subject (<spanx style="verb">sub</spanx>) of
        this JWT identifies the party ("ltc@example.net") that is the actor that will use the requested security token.
        The on-behalf-of (<spanx style="verb">obo</spanx>) claim asserts that the presenter is allowed to act for "acc@example.net".
      </t>
      <figure>
        <artwork><![CDATA[
 {
  "aud":"example.com",
  "iss":"example.net",
  "exp":1441910060,
  "ctx":["status","feed"],
  "obo":"acc@example.net",
  "sub":"ltc@example.net"
 }
]]></artwork>
      </figure>
    </section>

    <section title="Token Exchange Response">
      <t>
        The <spanx style="verb">access_token</spanx> parameter of the token exchange
        response shown below contains the new token that the client requested.
        The other parameters of the response
        indicates that the token is a JWT that expires in an hour.
      </t>
      <figure>
        <artwork><![CDATA[
 HTTP/1.1 200 OK
 Content-Type: application/json
 Cache-Control: no-cache, no-store

 {
  "access_token":"eyJhbGciOiJFUzI1NiIsImtpZCI6IjcyIn0.eyJhdWQiOiJle
    GFtcGxlLm9yZyIsImlzcyI6ImV4YW1wbGUuY29tIiwiZXhwIjoxNDQxOTEzNjEw
    LCJjdHgiOlsic3RhdHVzIiwiZmVlZCJdLCJhY3QiOiJsdGNAZXhhbXBsZS5uZXQ
    iLCJzdWIiOiJhY2NAZXhhbXBsZS5uZXQifQ.Oq_CJ6Fdf5R8-mLfkZfVfoVKIrW
    oHoh_V4NSKZQVnezSLMahkipL6dj-KKwp8JCdiEiXzHW2lRta-gfl9pGCyQ",
  "token_type":"Bearer",
  "requested_token_type":"jwt"
  "expires_in":3600,
 }
]]></artwork>
      </figure>
      <!-- JWT signing key for example.com
       {"kty":"EC","kid":"72","use":"sig","alg":"ES256",
       "x":"472aI8TvDdm2qfBRpXYw0uZ7feumuQOM-RPRkkTukSo",
       "y":"VNNStdPhuxY6q7XfVIeYSW7xh_a4z5W2MCtNmQDcILc",
       "crv":"P-256",
       "d":"dtJiut8QBJxACG6fcX8NYnzIsAN1muCJvaMiLSrOjIc"}

      -->
    </section>

    <section title="Requested Token Claims">
      <t>
        The decoded claim set of the requested token is shown below. The new JWT is
        issued by the authorization server and intended for consumption by a system entity
        known by the logical name "example.org" anytime before the its expiration.
        The subject (<spanx style="verb">sub</spanx>) of
        the JWT is the same as the subject of the <spanx style="verb">subject_token</spanx> used to make the request.
        The actor (<spanx style="verb">act</spanx>) of the JWT is the same as the subject of
        the <spanx style="verb">delegate_token</spanx> used to make the request.

        This indicates delegation and identifies "ltc@example.net" as the current actor to whom authority
        has been delegated to act on behalf of "acc@example.net".
      </t>
      <figure>
        <artwork><![CDATA[
 {
  "aud":"example.org",
  "iss":"example.com",
  "exp":1441913610,
  "ctx":["status","feed"],
  "act":"ltc@example.net",
  "sub":"acc@example.net"
 }
]]></artwork>
      </figure>
    </section>
  </section>

  </section>

    <section title='Acknowledgements'>
      <t>
        This specification was developed within the OAuth Working Group, which
        includes dozens of active and dedicated participants.
        It was produced under the chairmanship of
        Hannes Tschofenig and Derek Atkins while
        Kathleen Moriarty and Stephen Farrell served as
        Security Area Directors.
        In particular,
        the following individuals contributed ideas, feedback, and wording
        that shaped and formed the final specification:
      </t>
      <t>
        Hannes Tschofenig, Jason Keglovitz, Justin Richter, Matt Miller, Matthew Perry, Phil Hunt, Scott Tomilson and William Denniss.
      </t>
    </section>

    <section title="Document History">
      <t>
	[[ to be removed by the RFC Editor before publication as an RFC ]]
      </t>
      <t>
        -03
        <list style='symbols'>
          <t>Update document editors (add Campbell, Bradley and Mortimore).</t>
          <t>Update title per slide 7 of https://www.ietf.org/proceedings/93/slides/slides-93-oauth-0.pdf</t>
          <t>Elaborate some more in the abstract and introduction.</t>
          <t>
            Update the format of the request to use application/x-www-form-urlencoded request parameters and
            the response to use the existing JSON params defined in OAuth per consensus out of the meeting in
            Prague https://www.ietf.org/proceedings/93/minutes/minutes-93-oauth
          </t>
          <t>Change grant type to urn:ietf:params:oauth:grant-type:token-exchange</t>
          <t>
            RFC 6755 registration requests to IANA for urn:ietf:params:oauth:token-type:refresh_token,
            urn:ietf:params:oauth:token-type:access_token and urn:ietf:params:oauth:grant-type:token-exchange
          </t>
          <t>
            RFC 6749 registration requests for request/response parameters.
          </t>
          <t>
            Token type values can now have shorthand value of something like just jwt with
            urn:ietf:params:oauth:token-type: as implied prefix.
          </t>
          <t>Remove Implementation Considerations and requirement to support JWTs.</t>
          <t>Attempt to clarify various bits of text throughout.</t>
          <t>
            Change on_behalf_of to subject_token, on_behalf_of_token_type to subject_token_type,
            act_as to delegate_token, and act_as_token_type to delegate_token_type per consensus to
            'pick new terms and descriptions' from the meeting in Prague
            Prague https://www.ietf.org/proceedings/93/minutes/minutes-93-oauth
          </t>
          <t>
            Add an audience request parameter used to indicate the logical name of the target service
            where the client intends to use the requested security token.
          </t>
          <t>
            Added JWT claims to express delegation (act/actor), context or scope (ctx/context), as well as an
            authorization to act for or on behalf of (obo/on-behalf-of conceptually borrowed from http://self-issued.info/docs/on-behalf-of.html) (+ RFC 7519 registration requests for them).
          </t>
          <t>Added examples.</t>
        </list>
      </t>
      <t>
        -02
        <list style='symbols'>
	  <t>
	    Enabled use of Security Token types other than JWTs for
	    <spanx style="verb">act_as</spanx> and
	    <spanx style="verb">on_behalf_of</spanx> request values.
	  </t>
          <t>
            Referenced the JWT and OAuth Assertions RFCs.
	  </t>
        </list>
      </t>

      <t>
        -01
        <list style='symbols'>
          <t>
            Updated references.
	  </t>
        </list>
      </t>

      <t>
        -00
        <list style='symbols'>
          <t>
            Created initial working group draft from draft-jones-oauth-token-exchange-01.
	  </t>
        </list>
      </t>
    </section>     

  </back>
</rfc>
  <!--   code used to create the JWTs in examples


import org.jose4j.jwk.JsonWebKey;
import org.jose4j.jwk.PublicJsonWebKey;

import org.jose4j.jws.AlgorithmIdentifiers;
import org.jose4j.jws.JsonWebSignature;
import org.jose4j.jwt.JwtClaims;
import org.jose4j.jwt.NumericDate;

public class TokenExExamples
{
    public static void main(String[] args) throws Exception
    {
        System.out.println("main-example");
        System.out.println(" main :::::");

        PublicJsonWebKey mainExKey = PublicJsonWebKey.Factory.newPublicJwk("{\"kty\":\"EC\",\"kid\":\"9er\",\"use\":\"sig\",\"alg\":\"ES256\",\"x\":\"5yoR9FjZHn7kJDALhDzhZ8i8F06mc12YswUMTBv4BoA\",\"y\":\"4uxuIItWj5Duzspth5mUbpLXWrPFzFPQkOCeAGGI6KM\",\"crv\":\"P-256\",\"d\":\"LncS7zrx6c8X5qZRxoSN18ZEYDeI2wfKfUvX_DgwRH8\"}");
        System.out.println(mainExKey.toJson(JsonWebKey.OutputControlLevel.INCLUDE_PRIVATE));

        NumericDate iat = NumericDate.fromSeconds(1441917533);
        System.out.println(iat);
        NumericDate exp = NumericDate.fromSeconds(iat.getValue());
        exp.addSeconds(60);

        JwtClaims claims = new JwtClaims();
        claims.setAudience("backend.example.com");
        claims.setIssuer("as.example.com");
        claims.setExpirationTime(exp);
        claims.setIssuedAt(iat);
        claims.setStringClaim("azp", "rs08");
        claims.setSubject("bcampbell@example.com");
        claims.setStringListClaim("ctx", "api");

        JsonWebSignature jws = new JsonWebSignature();
        jws.setAlgorithmHeaderValue(AlgorithmIdentifiers.ECDSA_USING_P256_CURVE_AND_SHA256);
        jws.setKeyIdHeaderValue(mainExKey.getKeyId());
        jws.setKey(mainExKey.getPrivateKey());
        jws.setPayload(claims.toJson());
        System.out.println(jws.getCompactSerialization());


        System.out.println("impersonation-example");
        System.out.println("\n dot net:::::");
        PublicJsonWebKey dotNetKey = PublicJsonWebKey.Factory.newPublicJwk("{\"kty\":\"EC\",\"kid\":\"16\",\"use\":\"sig\",\"alg\":\"ES256\",\"x\":\"N_MqlYd_Iq0rfzTqXAX7TUC0r7fQSp3YQKh42tn7uSc\",\"y\":\"9tGuwMFkHYWPqkLa51f8GazZNQqdgMOVvJEd6fJ18PI\",\"crv\":\"P-256\",\"d\":\"cZ_4DqRSAWMMErQbKv6dCYqI9G1pi6lxvlvHU152Uts\"}");
        System.out.println(dotNetKey.toJson(JsonWebKey.OutputControlLevel.INCLUDE_PRIVATE));

        iat = NumericDate.fromSeconds(1441910000);
        System.out.println(iat);
        exp = NumericDate.fromSeconds(iat.getValue());
        exp.addSeconds(600);
        NumericDate nbf = NumericDate.fromSeconds(iat.getValue());
        nbf.addSeconds(-1000);

        claims = new JwtClaims();
        claims.setAudience("example.com");
        claims.setIssuer("example.net");
        claims.setExpirationTime(exp);
        claims.setNotBefore(nbf);
        claims.setSubject("bc@example.net");
        claims.setStringListClaim("ctx", "orders", "profile", "history");

        jws = new JsonWebSignature();
        jws.setAlgorithmHeaderValue(AlgorithmIdentifiers.ECDSA_USING_P256_CURVE_AND_SHA256);
        jws.setKeyIdHeaderValue(dotNetKey.getKeyId());
        jws.setKey(dotNetKey.getPrivateKey());
        String payload = claims.toJson();
        jws.setPayload(payload);
        System.out.println(payload);
        System.out.println("sub token: " + jws.getCompactSerialization());

        System.out.println("\n dot com:::::");
        PublicJsonWebKey dotComKey = PublicJsonWebKey.Factory.newPublicJwk("{\"kty\":\"EC\",\"kid\":\"72\",\"use\":\"sig\",\"alg\":\"ES256\",\"x\":\"472aI8TvDdm2qfBRpXYw0uZ7feumuQOM-RPRkkTukSo\",\"y\":\"VNNStdPhuxY6q7XfVIeYSW7xh_a4z5W2MCtNmQDcILc\",\"crv\":\"P-256\",\"d\":\"dtJiut8QBJxACG6fcX8NYnzIsAN1muCJvaMiLSrOjIc\"}");
        System.out.println(dotComKey.toJson(JsonWebKey.OutputControlLevel.INCLUDE_PRIVATE));

        iat = NumericDate.fromSeconds(1441910010);
        System.out.println(iat);
        exp = NumericDate.fromSeconds(iat.getValue());
        exp.addSeconds(3600);

        claims = new JwtClaims();
        claims.setAudience("example.org");
        claims.setIssuer("example.com");
        claims.setExpirationTime(exp);
        claims.setSubject("bc@example.net");
        claims.setStringListClaim("ctx", "orders", "history", "profile");

        jws = new JsonWebSignature();
        jws.setAlgorithmHeaderValue(AlgorithmIdentifiers.ECDSA_USING_P256_CURVE_AND_SHA256);
        jws.setKeyIdHeaderValue(dotComKey.getKeyId());
        jws.setKey(dotComKey.getPrivateKey());
        payload = claims.toJson();
        jws.setPayload(payload);
        System.out.println(payload);
        System.out.println("requested token: " + jws.getCompactSerialization());


        System.out.println("\n\n\ndelegation-example");
        System.out.println("\n dot net:::::");


        iat = NumericDate.fromSeconds(1441910000);
        System.out.println(iat);
        exp = NumericDate.fromSeconds(iat.getValue());
        exp.addSeconds(60);

        claims = new JwtClaims();
        claims.setAudience("example.com");
        claims.setIssuer("example.net");
        claims.setExpirationTime(exp);
        String acc = "acc@example.net";
        claims.setSubject(acc);

        jws = new JsonWebSignature();
        jws.setAlgorithmHeaderValue(AlgorithmIdentifiers.ECDSA_USING_P256_CURVE_AND_SHA256);
        jws.setKeyIdHeaderValue(dotNetKey.getKeyId());
        jws.setKey(dotNetKey.getPrivateKey());
        payload = claims.toJson();
        jws.setPayload(payload);
        System.out.println(payload);
        System.out.println("sub token: " + jws.getCompactSerialization());

        String ltc = "ltc@example.net";

        claims = new JwtClaims();
        claims.setAudience("example.com");
        claims.setIssuer("example.net");
        claims.setExpirationTime(exp);
        claims.setStringListClaim("ctx", "status", "feed");
        claims.setStringClaim("obo", acc);
        claims.setSubject(ltc);

        jws = new JsonWebSignature();
        jws.setAlgorithmHeaderValue(AlgorithmIdentifiers.ECDSA_USING_P256_CURVE_AND_SHA256);
        jws.setKeyIdHeaderValue(dotNetKey.getKeyId());
        jws.setKey(dotNetKey.getPrivateKey());
        payload = claims.toJson();
        jws.setPayload(payload);
        System.out.println(payload);
        System.out.println("del token: " + jws.getCompactSerialization());

        iat = NumericDate.fromSeconds(1441910010);
        System.out.println(iat);
        exp = NumericDate.fromSeconds(iat.getValue());
        exp.addSeconds(3600);

        claims = new JwtClaims();
        claims.setAudience("example.org");
        claims.setIssuer("example.com");
        claims.setExpirationTime(exp);
        claims.setStringListClaim("ctx", "status", "feed");
        claims.setStringClaim("act", ltc);
        claims.setSubject(acc);

        jws = new JsonWebSignature();
        jws.setAlgorithmHeaderValue(AlgorithmIdentifiers.ECDSA_USING_P256_CURVE_AND_SHA256);
        jws.setKeyIdHeaderValue(dotComKey.getKeyId());
        jws.setKey(dotComKey.getPrivateKey());
        payload = claims.toJson();
        jws.setPayload(payload);
        System.out.println(payload);
        System.out.println("requested token: " + jws.getCompactSerialization());
    }
}

-->